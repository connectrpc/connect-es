// This is copied from gRPC's testing Protobuf definitions: https://github.com/grpc/grpc/blob/master/src/proto/grpc/testing/messages.proto

// Copyright 2015-2016 gRPC authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Message definitions to be used by integration test service definitions.

// @generated by protoc-gen-es v0.1.1 with parameter "ts_nocheck=false,target=ts"
// @generated from file grpc/testing/messages.proto (package grpc.testing, syntax proto3)
/* eslint-disable */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Any, Message, proto3} from "@bufbuild/protobuf";

/**
 * The type of payload that should be returned.
 *
 * @generated from enum grpc.testing.PayloadType
 */
export enum PayloadType {
  /**
   * Compressable text format.
   *
   * @generated from enum value: COMPRESSABLE = 0;
   */
  COMPRESSABLE = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(PayloadType)
proto3.util.setEnumType(PayloadType, "grpc.testing.PayloadType", [
  { no: 0, name: "COMPRESSABLE" },
]);

/**
 * The type of route that a client took to reach a server w.r.t. gRPCLB.
 * The server must fill in "fallback" if it detects that the RPC reached
 * the server via the "gRPCLB fallback" path, and "backend" if it detects
 * that the RPC reached the server via "gRPCLB backend" path (i.e. if it got
 * the address of this server from the gRPCLB server BalanceLoad RPC). Exactly
 * how this detection is done is context and server dependent.
 *
 * @generated from enum grpc.testing.GrpclbRouteType
 */
export enum GrpclbRouteType {
  /**
   * Server didn't detect the route that a client took to reach it.
   *
   * @generated from enum value: GRPCLB_ROUTE_TYPE_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Indicates that a client reached a server via gRPCLB fallback.
   *
   * @generated from enum value: GRPCLB_ROUTE_TYPE_FALLBACK = 1;
   */
  FALLBACK = 1,

  /**
   * Indicates that a client reached a server as a gRPCLB-given backend.
   *
   * @generated from enum value: GRPCLB_ROUTE_TYPE_BACKEND = 2;
   */
  BACKEND = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(GrpclbRouteType)
proto3.util.setEnumType(GrpclbRouteType, "grpc.testing.GrpclbRouteType", [
  { no: 0, name: "GRPCLB_ROUTE_TYPE_UNKNOWN" },
  { no: 1, name: "GRPCLB_ROUTE_TYPE_FALLBACK" },
  { no: 2, name: "GRPCLB_ROUTE_TYPE_BACKEND" },
]);

/**
 * TODO(dgq): Go back to using well-known types once
 * https://github.com/grpc/grpc/issues/6980 has been fixed.
 * import "google/protobuf/wrappers.proto";
 *
 * @generated from message grpc.testing.BoolValue
 */
export class BoolValue extends Message<BoolValue> {
  /**
   * The bool value.
   *
   * @generated from field: bool value = 1;
   */
  value = false;

  constructor(data?: PartialMessage<BoolValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.BoolValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BoolValue {
    return new BoolValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BoolValue {
    return new BoolValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BoolValue {
    return new BoolValue().fromJsonString(jsonString, options);
  }

  static equals(a: BoolValue | PlainMessage<BoolValue> | undefined, b: BoolValue | PlainMessage<BoolValue> | undefined): boolean {
    return proto3.util.equals(BoolValue, a, b);
  }
}

/**
 * A block of data, to simply increase gRPC message size.
 *
 * @generated from message grpc.testing.Payload
 */
export class Payload extends Message<Payload> {
  /**
   * The type of data in body.
   *
   * @generated from field: grpc.testing.PayloadType type = 1;
   */
  type = PayloadType.COMPRESSABLE;

  /**
   * Primary contents of payload.
   *
   * @generated from field: bytes body = 2;
   */
  body = new Uint8Array(0);

  constructor(data?: PartialMessage<Payload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.Payload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(PayloadType) },
    { no: 2, name: "body", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Payload {
    return new Payload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Payload {
    return new Payload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Payload {
    return new Payload().fromJsonString(jsonString, options);
  }

  static equals(a: Payload | PlainMessage<Payload> | undefined, b: Payload | PlainMessage<Payload> | undefined): boolean {
    return proto3.util.equals(Payload, a, b);
  }
}

/**
 * A protobuf representation for grpc status. This is used by test
 * clients to specify a status that the server should attempt to return.
 *
 * @generated from message grpc.testing.EchoStatus
 */
export class EchoStatus extends Message<EchoStatus> {
  /**
   * @generated from field: int32 code = 1;
   */
  code = 0;

  /**
   * @generated from field: string message = 2;
   */
  message = "";

  constructor(data?: PartialMessage<EchoStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.EchoStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EchoStatus {
    return new EchoStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EchoStatus {
    return new EchoStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EchoStatus {
    return new EchoStatus().fromJsonString(jsonString, options);
  }

  static equals(a: EchoStatus | PlainMessage<EchoStatus> | undefined, b: EchoStatus | PlainMessage<EchoStatus> | undefined): boolean {
    return proto3.util.equals(EchoStatus, a, b);
  }
}

/**
 * Unary request.
 *
 * @generated from message grpc.testing.SimpleRequest
 */
export class SimpleRequest extends Message<SimpleRequest> {
  /**
   * Desired payload type in the response from the server.
   * If response_type is RANDOM, server randomly chooses one from other formats.
   *
   * @generated from field: grpc.testing.PayloadType response_type = 1;
   */
  responseType = PayloadType.COMPRESSABLE;

  /**
   * Desired payload size in the response from the server.
   *
   * @generated from field: int32 response_size = 2;
   */
  responseSize = 0;

  /**
   * Optional input payload sent along with the request.
   *
   * @generated from field: grpc.testing.Payload payload = 3;
   */
  payload?: Payload;

  /**
   * Whether SimpleResponse should include username.
   *
   * @generated from field: bool fill_username = 4;
   */
  fillUsername = false;

  /**
   * Whether SimpleResponse should include OAuth scope.
   *
   * @generated from field: bool fill_oauth_scope = 5;
   */
  fillOauthScope = false;

  /**
   * Whether to request the server to compress the response. This field is
   * "nullable" in order to interoperate seamlessly with clients not able to
   * implement the full compression tests by introspecting the call to verify
   * the response's compression status.
   *
   * @generated from field: grpc.testing.BoolValue response_compressed = 6;
   */
  responseCompressed?: BoolValue;

  /**
   * Whether server should return a given status
   *
   * @generated from field: grpc.testing.EchoStatus response_status = 7;
   */
  responseStatus?: EchoStatus;

  /**
   * Whether the server should expect this request to be compressed.
   *
   * @generated from field: grpc.testing.BoolValue expect_compressed = 8;
   */
  expectCompressed?: BoolValue;

  /**
   * Whether SimpleResponse should include server_id.
   *
   * @generated from field: bool fill_server_id = 9;
   */
  fillServerId = false;

  /**
   * Whether SimpleResponse should include grpclb_route_type.
   *
   * @generated from field: bool fill_grpclb_route_type = 10;
   */
  fillGrpclbRouteType = false;

  constructor(data?: PartialMessage<SimpleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.SimpleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response_type", kind: "enum", T: proto3.getEnumType(PayloadType) },
    { no: 2, name: "response_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "payload", kind: "message", T: Payload },
    { no: 4, name: "fill_username", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "fill_oauth_scope", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "response_compressed", kind: "message", T: BoolValue },
    { no: 7, name: "response_status", kind: "message", T: EchoStatus },
    { no: 8, name: "expect_compressed", kind: "message", T: BoolValue },
    { no: 9, name: "fill_server_id", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "fill_grpclb_route_type", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SimpleRequest {
    return new SimpleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SimpleRequest {
    return new SimpleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SimpleRequest {
    return new SimpleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SimpleRequest | PlainMessage<SimpleRequest> | undefined, b: SimpleRequest | PlainMessage<SimpleRequest> | undefined): boolean {
    return proto3.util.equals(SimpleRequest, a, b);
  }
}

/**
 * Unary response, as configured by the request.
 *
 * @generated from message grpc.testing.SimpleResponse
 */
export class SimpleResponse extends Message<SimpleResponse> {
  /**
   * Payload to increase message size.
   *
   * @generated from field: grpc.testing.Payload payload = 1;
   */
  payload?: Payload;

  /**
   * The user the request came from, for verifying authentication was
   * successful when the client expected it.
   *
   * @generated from field: string username = 2;
   */
  username = "";

  /**
   * OAuth scope.
   *
   * @generated from field: string oauth_scope = 3;
   */
  oauthScope = "";

  /**
   * Server ID. This must be unique among different server instances,
   * but the same across all RPC's made to a particular server instance.
   *
   * @generated from field: string server_id = 4;
   */
  serverId = "";

  /**
   * gRPCLB Path.
   *
   * @generated from field: grpc.testing.GrpclbRouteType grpclb_route_type = 5;
   */
  grpclbRouteType = GrpclbRouteType.UNKNOWN;

  /**
   * Server hostname.
   *
   * @generated from field: string hostname = 6;
   */
  hostname = "";

  constructor(data?: PartialMessage<SimpleResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.SimpleResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "payload", kind: "message", T: Payload },
    { no: 2, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "oauth_scope", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "server_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "grpclb_route_type", kind: "enum", T: proto3.getEnumType(GrpclbRouteType) },
    { no: 6, name: "hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SimpleResponse {
    return new SimpleResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SimpleResponse {
    return new SimpleResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SimpleResponse {
    return new SimpleResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SimpleResponse | PlainMessage<SimpleResponse> | undefined, b: SimpleResponse | PlainMessage<SimpleResponse> | undefined): boolean {
    return proto3.util.equals(SimpleResponse, a, b);
  }
}

/**
 * Client-streaming request.
 *
 * @generated from message grpc.testing.StreamingInputCallRequest
 */
export class StreamingInputCallRequest extends Message<StreamingInputCallRequest> {
  /**
   * Optional input payload sent along with the request.
   *
   * @generated from field: grpc.testing.Payload payload = 1;
   */
  payload?: Payload;

  /**
   * Whether the server should expect this request to be compressed. This field
   * is "nullable" in order to interoperate seamlessly with servers not able to
   * implement the full compression tests by introspecting the call to verify
   * the request's compression status.
   *
   * @generated from field: grpc.testing.BoolValue expect_compressed = 2;
   */
  expectCompressed?: BoolValue;

  constructor(data?: PartialMessage<StreamingInputCallRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.StreamingInputCallRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "payload", kind: "message", T: Payload },
    { no: 2, name: "expect_compressed", kind: "message", T: BoolValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamingInputCallRequest {
    return new StreamingInputCallRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamingInputCallRequest {
    return new StreamingInputCallRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamingInputCallRequest {
    return new StreamingInputCallRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamingInputCallRequest | PlainMessage<StreamingInputCallRequest> | undefined, b: StreamingInputCallRequest | PlainMessage<StreamingInputCallRequest> | undefined): boolean {
    return proto3.util.equals(StreamingInputCallRequest, a, b);
  }
}

/**
 * Client-streaming response.
 *
 * @generated from message grpc.testing.StreamingInputCallResponse
 */
export class StreamingInputCallResponse extends Message<StreamingInputCallResponse> {
  /**
   * Aggregated size of payloads received from the client.
   *
   * @generated from field: int32 aggregated_payload_size = 1;
   */
  aggregatedPayloadSize = 0;

  constructor(data?: PartialMessage<StreamingInputCallResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.StreamingInputCallResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "aggregated_payload_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamingInputCallResponse {
    return new StreamingInputCallResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamingInputCallResponse {
    return new StreamingInputCallResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamingInputCallResponse {
    return new StreamingInputCallResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamingInputCallResponse | PlainMessage<StreamingInputCallResponse> | undefined, b: StreamingInputCallResponse | PlainMessage<StreamingInputCallResponse> | undefined): boolean {
    return proto3.util.equals(StreamingInputCallResponse, a, b);
  }
}

/**
 * Configuration for a particular response.
 *
 * @generated from message grpc.testing.ResponseParameters
 */
export class ResponseParameters extends Message<ResponseParameters> {
  /**
   * Desired payload sizes in responses from the server.
   *
   * @generated from field: int32 size = 1;
   */
  size = 0;

  /**
   * Desired interval between consecutive responses in the response stream in
   * microseconds.
   *
   * @generated from field: int32 interval_us = 2;
   */
  intervalUs = 0;

  /**
   * Whether to request the server to compress the response. This field is
   * "nullable" in order to interoperate seamlessly with clients not able to
   * implement the full compression tests by introspecting the call to verify
   * the response's compression status.
   *
   * @generated from field: grpc.testing.BoolValue compressed = 3;
   */
  compressed?: BoolValue;

  constructor(data?: PartialMessage<ResponseParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.ResponseParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "interval_us", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "compressed", kind: "message", T: BoolValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResponseParameters {
    return new ResponseParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResponseParameters {
    return new ResponseParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResponseParameters {
    return new ResponseParameters().fromJsonString(jsonString, options);
  }

  static equals(a: ResponseParameters | PlainMessage<ResponseParameters> | undefined, b: ResponseParameters | PlainMessage<ResponseParameters> | undefined): boolean {
    return proto3.util.equals(ResponseParameters, a, b);
  }
}

/**
 * Server-streaming request.
 *
 * @generated from message grpc.testing.StreamingOutputCallRequest
 */
export class StreamingOutputCallRequest extends Message<StreamingOutputCallRequest> {
  /**
   * Desired payload type in the response from the server.
   * If response_type is RANDOM, the payload from each response in the stream
   * might be of different types. This is to simulate a mixed type of payload
   * stream.
   *
   * @generated from field: grpc.testing.PayloadType response_type = 1;
   */
  responseType = PayloadType.COMPRESSABLE;

  /**
   * Configuration for each expected response message.
   *
   * @generated from field: repeated grpc.testing.ResponseParameters response_parameters = 2;
   */
  responseParameters: ResponseParameters[] = [];

  /**
   * Optional input payload sent along with the request.
   *
   * @generated from field: grpc.testing.Payload payload = 3;
   */
  payload?: Payload;

  /**
   * Whether server should return a given status
   *
   * @generated from field: grpc.testing.EchoStatus response_status = 7;
   */
  responseStatus?: EchoStatus;

  constructor(data?: PartialMessage<StreamingOutputCallRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.StreamingOutputCallRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response_type", kind: "enum", T: proto3.getEnumType(PayloadType) },
    { no: 2, name: "response_parameters", kind: "message", T: ResponseParameters, repeated: true },
    { no: 3, name: "payload", kind: "message", T: Payload },
    { no: 7, name: "response_status", kind: "message", T: EchoStatus },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamingOutputCallRequest {
    return new StreamingOutputCallRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamingOutputCallRequest {
    return new StreamingOutputCallRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamingOutputCallRequest {
    return new StreamingOutputCallRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamingOutputCallRequest | PlainMessage<StreamingOutputCallRequest> | undefined, b: StreamingOutputCallRequest | PlainMessage<StreamingOutputCallRequest> | undefined): boolean {
    return proto3.util.equals(StreamingOutputCallRequest, a, b);
  }
}

/**
 * Server-streaming response, as configured by the request and parameters.
 *
 * @generated from message grpc.testing.StreamingOutputCallResponse
 */
export class StreamingOutputCallResponse extends Message<StreamingOutputCallResponse> {
  /**
   * Payload to increase response size.
   *
   * @generated from field: grpc.testing.Payload payload = 1;
   */
  payload?: Payload;

  constructor(data?: PartialMessage<StreamingOutputCallResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.StreamingOutputCallResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "payload", kind: "message", T: Payload },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamingOutputCallResponse {
    return new StreamingOutputCallResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamingOutputCallResponse {
    return new StreamingOutputCallResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamingOutputCallResponse {
    return new StreamingOutputCallResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamingOutputCallResponse | PlainMessage<StreamingOutputCallResponse> | undefined, b: StreamingOutputCallResponse | PlainMessage<StreamingOutputCallResponse> | undefined): boolean {
    return proto3.util.equals(StreamingOutputCallResponse, a, b);
  }
}

/**
 * For reconnect interop test only.
 * Client tells server what reconnection parameters it used.
 *
 * @generated from message grpc.testing.ReconnectParams
 */
export class ReconnectParams extends Message<ReconnectParams> {
  /**
   * @generated from field: int32 max_reconnect_backoff_ms = 1;
   */
  maxReconnectBackoffMs = 0;

  constructor(data?: PartialMessage<ReconnectParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.ReconnectParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "max_reconnect_backoff_ms", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReconnectParams {
    return new ReconnectParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReconnectParams {
    return new ReconnectParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReconnectParams {
    return new ReconnectParams().fromJsonString(jsonString, options);
  }

  static equals(a: ReconnectParams | PlainMessage<ReconnectParams> | undefined, b: ReconnectParams | PlainMessage<ReconnectParams> | undefined): boolean {
    return proto3.util.equals(ReconnectParams, a, b);
  }
}

/**
 * For reconnect interop test only.
 * Server tells client whether its reconnects are following the spec and the
 * reconnect backoffs it saw.
 *
 * @generated from message grpc.testing.ReconnectInfo
 */
export class ReconnectInfo extends Message<ReconnectInfo> {
  /**
   * @generated from field: bool passed = 1;
   */
  passed = false;

  /**
   * @generated from field: repeated int32 backoff_ms = 2;
   */
  backoffMs: number[] = [];

  constructor(data?: PartialMessage<ReconnectInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.ReconnectInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "passed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "backoff_ms", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReconnectInfo {
    return new ReconnectInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReconnectInfo {
    return new ReconnectInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReconnectInfo {
    return new ReconnectInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ReconnectInfo | PlainMessage<ReconnectInfo> | undefined, b: ReconnectInfo | PlainMessage<ReconnectInfo> | undefined): boolean {
    return proto3.util.equals(ReconnectInfo, a, b);
  }
}

/**
 * @generated from message grpc.testing.LoadBalancerStatsRequest
 */
export class LoadBalancerStatsRequest extends Message<LoadBalancerStatsRequest> {
  /**
   * Request stats for the next num_rpcs sent by client.
   *
   * @generated from field: int32 num_rpcs = 1;
   */
  numRpcs = 0;

  /**
   * If num_rpcs have not completed within timeout_sec, return partial results.
   *
   * @generated from field: int32 timeout_sec = 2;
   */
  timeoutSec = 0;

  constructor(data?: PartialMessage<LoadBalancerStatsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.LoadBalancerStatsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "num_rpcs", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "timeout_sec", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoadBalancerStatsRequest {
    return new LoadBalancerStatsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoadBalancerStatsRequest {
    return new LoadBalancerStatsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoadBalancerStatsRequest {
    return new LoadBalancerStatsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LoadBalancerStatsRequest | PlainMessage<LoadBalancerStatsRequest> | undefined, b: LoadBalancerStatsRequest | PlainMessage<LoadBalancerStatsRequest> | undefined): boolean {
    return proto3.util.equals(LoadBalancerStatsRequest, a, b);
  }
}

/**
 * @generated from message grpc.testing.LoadBalancerStatsResponse
 */
export class LoadBalancerStatsResponse extends Message<LoadBalancerStatsResponse> {
  /**
   * The number of completed RPCs for each peer.
   *
   * @generated from field: map<string, int32> rpcs_by_peer = 1;
   */
  rpcsByPeer: { [key: string]: number } = {};

  /**
   * The number of RPCs that failed to record a remote peer.
   *
   * @generated from field: int32 num_failures = 2;
   */
  numFailures = 0;

  /**
   * @generated from field: map<string, grpc.testing.LoadBalancerStatsResponse.RpcsByPeer> rpcs_by_method = 3;
   */
  rpcsByMethod: { [key: string]: LoadBalancerStatsResponse_RpcsByPeer } = {};

  constructor(data?: PartialMessage<LoadBalancerStatsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.LoadBalancerStatsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rpcs_by_peer", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 5 /* ScalarType.INT32 */} },
    { no: 2, name: "num_failures", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "rpcs_by_method", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: LoadBalancerStatsResponse_RpcsByPeer} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoadBalancerStatsResponse {
    return new LoadBalancerStatsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoadBalancerStatsResponse {
    return new LoadBalancerStatsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoadBalancerStatsResponse {
    return new LoadBalancerStatsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LoadBalancerStatsResponse | PlainMessage<LoadBalancerStatsResponse> | undefined, b: LoadBalancerStatsResponse | PlainMessage<LoadBalancerStatsResponse> | undefined): boolean {
    return proto3.util.equals(LoadBalancerStatsResponse, a, b);
  }
}

/**
 * @generated from message grpc.testing.LoadBalancerStatsResponse.RpcsByPeer
 */
export class LoadBalancerStatsResponse_RpcsByPeer extends Message<LoadBalancerStatsResponse_RpcsByPeer> {
  /**
   * The number of completed RPCs for each peer.
   *
   * @generated from field: map<string, int32> rpcs_by_peer = 1;
   */
  rpcsByPeer: { [key: string]: number } = {};

  constructor(data?: PartialMessage<LoadBalancerStatsResponse_RpcsByPeer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.LoadBalancerStatsResponse.RpcsByPeer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rpcs_by_peer", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 5 /* ScalarType.INT32 */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoadBalancerStatsResponse_RpcsByPeer {
    return new LoadBalancerStatsResponse_RpcsByPeer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoadBalancerStatsResponse_RpcsByPeer {
    return new LoadBalancerStatsResponse_RpcsByPeer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoadBalancerStatsResponse_RpcsByPeer {
    return new LoadBalancerStatsResponse_RpcsByPeer().fromJsonString(jsonString, options);
  }

  static equals(a: LoadBalancerStatsResponse_RpcsByPeer | PlainMessage<LoadBalancerStatsResponse_RpcsByPeer> | undefined, b: LoadBalancerStatsResponse_RpcsByPeer | PlainMessage<LoadBalancerStatsResponse_RpcsByPeer> | undefined): boolean {
    return proto3.util.equals(LoadBalancerStatsResponse_RpcsByPeer, a, b);
  }
}

/**
 * Request for retrieving a test client's accumulated stats.
 *
 * @generated from message grpc.testing.LoadBalancerAccumulatedStatsRequest
 */
export class LoadBalancerAccumulatedStatsRequest extends Message<LoadBalancerAccumulatedStatsRequest> {
  constructor(data?: PartialMessage<LoadBalancerAccumulatedStatsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.LoadBalancerAccumulatedStatsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoadBalancerAccumulatedStatsRequest {
    return new LoadBalancerAccumulatedStatsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoadBalancerAccumulatedStatsRequest {
    return new LoadBalancerAccumulatedStatsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoadBalancerAccumulatedStatsRequest {
    return new LoadBalancerAccumulatedStatsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LoadBalancerAccumulatedStatsRequest | PlainMessage<LoadBalancerAccumulatedStatsRequest> | undefined, b: LoadBalancerAccumulatedStatsRequest | PlainMessage<LoadBalancerAccumulatedStatsRequest> | undefined): boolean {
    return proto3.util.equals(LoadBalancerAccumulatedStatsRequest, a, b);
  }
}

/**
 * Accumulated stats for RPCs sent by a test client.
 *
 * @generated from message grpc.testing.LoadBalancerAccumulatedStatsResponse
 */
export class LoadBalancerAccumulatedStatsResponse extends Message<LoadBalancerAccumulatedStatsResponse> {
  /**
   * The total number of RPCs have ever issued for each type.
   * Deprecated: use stats_per_method.rpcs_started instead.
   *
   * @generated from field: map<string, int32> num_rpcs_started_by_method = 1 [deprecated = true];
   * @deprecated
   */
  numRpcsStartedByMethod: { [key: string]: number } = {};

  /**
   * The total number of RPCs have ever completed successfully for each type.
   * Deprecated: use stats_per_method.result instead.
   *
   * @generated from field: map<string, int32> num_rpcs_succeeded_by_method = 2 [deprecated = true];
   * @deprecated
   */
  numRpcsSucceededByMethod: { [key: string]: number } = {};

  /**
   * The total number of RPCs have ever failed for each type.
   * Deprecated: use stats_per_method.result instead.
   *
   * @generated from field: map<string, int32> num_rpcs_failed_by_method = 3 [deprecated = true];
   * @deprecated
   */
  numRpcsFailedByMethod: { [key: string]: number } = {};

  /**
   * Per-method RPC statistics.  The key is the RpcType in string form; e.g.
   * 'EMPTY_CALL' or 'UNARY_CALL'
   *
   * @generated from field: map<string, grpc.testing.LoadBalancerAccumulatedStatsResponse.MethodStats> stats_per_method = 4;
   */
  statsPerMethod: { [key: string]: LoadBalancerAccumulatedStatsResponse_MethodStats } = {};

  constructor(data?: PartialMessage<LoadBalancerAccumulatedStatsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.LoadBalancerAccumulatedStatsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "num_rpcs_started_by_method", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 5 /* ScalarType.INT32 */} },
    { no: 2, name: "num_rpcs_succeeded_by_method", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 5 /* ScalarType.INT32 */} },
    { no: 3, name: "num_rpcs_failed_by_method", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 5 /* ScalarType.INT32 */} },
    { no: 4, name: "stats_per_method", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: LoadBalancerAccumulatedStatsResponse_MethodStats} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoadBalancerAccumulatedStatsResponse {
    return new LoadBalancerAccumulatedStatsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoadBalancerAccumulatedStatsResponse {
    return new LoadBalancerAccumulatedStatsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoadBalancerAccumulatedStatsResponse {
    return new LoadBalancerAccumulatedStatsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LoadBalancerAccumulatedStatsResponse | PlainMessage<LoadBalancerAccumulatedStatsResponse> | undefined, b: LoadBalancerAccumulatedStatsResponse | PlainMessage<LoadBalancerAccumulatedStatsResponse> | undefined): boolean {
    return proto3.util.equals(LoadBalancerAccumulatedStatsResponse, a, b);
  }
}

/**
 * @generated from message grpc.testing.LoadBalancerAccumulatedStatsResponse.MethodStats
 */
export class LoadBalancerAccumulatedStatsResponse_MethodStats extends Message<LoadBalancerAccumulatedStatsResponse_MethodStats> {
  /**
   * The number of RPCs that were started for this method.
   *
   * @generated from field: int32 rpcs_started = 1;
   */
  rpcsStarted = 0;

  /**
   * The number of RPCs that completed with each status for this method.  The
   * key is the integral value of a google.rpc.Code; the value is the count.
   *
   * @generated from field: map<int32, int32> result = 2;
   */
  result: { [key: number]: number } = {};

  constructor(data?: PartialMessage<LoadBalancerAccumulatedStatsResponse_MethodStats>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.LoadBalancerAccumulatedStatsResponse.MethodStats";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rpcs_started", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "result", kind: "map", K: 5 /* ScalarType.INT32 */, V: {kind: "scalar", T: 5 /* ScalarType.INT32 */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoadBalancerAccumulatedStatsResponse_MethodStats {
    return new LoadBalancerAccumulatedStatsResponse_MethodStats().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoadBalancerAccumulatedStatsResponse_MethodStats {
    return new LoadBalancerAccumulatedStatsResponse_MethodStats().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoadBalancerAccumulatedStatsResponse_MethodStats {
    return new LoadBalancerAccumulatedStatsResponse_MethodStats().fromJsonString(jsonString, options);
  }

  static equals(a: LoadBalancerAccumulatedStatsResponse_MethodStats | PlainMessage<LoadBalancerAccumulatedStatsResponse_MethodStats> | undefined, b: LoadBalancerAccumulatedStatsResponse_MethodStats | PlainMessage<LoadBalancerAccumulatedStatsResponse_MethodStats> | undefined): boolean {
    return proto3.util.equals(LoadBalancerAccumulatedStatsResponse_MethodStats, a, b);
  }
}

/**
 * Configurations for a test client.
 *
 * @generated from message grpc.testing.ClientConfigureRequest
 */
export class ClientConfigureRequest extends Message<ClientConfigureRequest> {
  /**
   * The types of RPCs the client sends.
   *
   * @generated from field: repeated grpc.testing.ClientConfigureRequest.RpcType types = 1;
   */
  types: ClientConfigureRequest_RpcType[] = [];

  /**
   * The collection of custom metadata to be attached to RPCs sent by the client.
   *
   * @generated from field: repeated grpc.testing.ClientConfigureRequest.Metadata metadata = 2;
   */
  metadata: ClientConfigureRequest_Metadata[] = [];

  /**
   * The deadline to use, in seconds, for all RPCs.  If unset or zero, the
   * client will use the default from the command-line.
   *
   * @generated from field: int32 timeout_sec = 3;
   */
  timeoutSec = 0;

  constructor(data?: PartialMessage<ClientConfigureRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.ClientConfigureRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "types", kind: "enum", T: proto3.getEnumType(ClientConfigureRequest_RpcType), repeated: true },
    { no: 2, name: "metadata", kind: "message", T: ClientConfigureRequest_Metadata, repeated: true },
    { no: 3, name: "timeout_sec", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientConfigureRequest {
    return new ClientConfigureRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientConfigureRequest {
    return new ClientConfigureRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientConfigureRequest {
    return new ClientConfigureRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ClientConfigureRequest | PlainMessage<ClientConfigureRequest> | undefined, b: ClientConfigureRequest | PlainMessage<ClientConfigureRequest> | undefined): boolean {
    return proto3.util.equals(ClientConfigureRequest, a, b);
  }
}

/**
 * Type of RPCs to send.
 *
 * @generated from enum grpc.testing.ClientConfigureRequest.RpcType
 */
export enum ClientConfigureRequest_RpcType {
  /**
   * @generated from enum value: EMPTY_CALL = 0;
   */
  EMPTY_CALL = 0,

  /**
   * @generated from enum value: UNARY_CALL = 1;
   */
  UNARY_CALL = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(ClientConfigureRequest_RpcType)
proto3.util.setEnumType(ClientConfigureRequest_RpcType, "grpc.testing.ClientConfigureRequest.RpcType", [
  { no: 0, name: "EMPTY_CALL" },
  { no: 1, name: "UNARY_CALL" },
]);

/**
 * Metadata to be attached for the given type of RPCs.
 *
 * @generated from message grpc.testing.ClientConfigureRequest.Metadata
 */
export class ClientConfigureRequest_Metadata extends Message<ClientConfigureRequest_Metadata> {
  /**
   * @generated from field: grpc.testing.ClientConfigureRequest.RpcType type = 1;
   */
  type = ClientConfigureRequest_RpcType.EMPTY_CALL;

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: string value = 3;
   */
  value = "";

  constructor(data?: PartialMessage<ClientConfigureRequest_Metadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.ClientConfigureRequest.Metadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(ClientConfigureRequest_RpcType) },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientConfigureRequest_Metadata {
    return new ClientConfigureRequest_Metadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientConfigureRequest_Metadata {
    return new ClientConfigureRequest_Metadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientConfigureRequest_Metadata {
    return new ClientConfigureRequest_Metadata().fromJsonString(jsonString, options);
  }

  static equals(a: ClientConfigureRequest_Metadata | PlainMessage<ClientConfigureRequest_Metadata> | undefined, b: ClientConfigureRequest_Metadata | PlainMessage<ClientConfigureRequest_Metadata> | undefined): boolean {
    return proto3.util.equals(ClientConfigureRequest_Metadata, a, b);
  }
}

/**
 * Response for updating a test client's configuration.
 *
 * @generated from message grpc.testing.ClientConfigureResponse
 */
export class ClientConfigureResponse extends Message<ClientConfigureResponse> {
  constructor(data?: PartialMessage<ClientConfigureResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.ClientConfigureResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientConfigureResponse {
    return new ClientConfigureResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientConfigureResponse {
    return new ClientConfigureResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientConfigureResponse {
    return new ClientConfigureResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ClientConfigureResponse | PlainMessage<ClientConfigureResponse> | undefined, b: ClientConfigureResponse | PlainMessage<ClientConfigureResponse> | undefined): boolean {
    return proto3.util.equals(ClientConfigureResponse, a, b);
  }
}

/**
 * @generated from message grpc.testing.ErrorDetail
 */
export class ErrorDetail extends Message<ErrorDetail> {
  /**
   * @generated from field: string reason = 1;
   */
  reason = "";

  /**
   * @generated from field: string domain = 2;
   */
  domain = "";

  constructor(data?: PartialMessage<ErrorDetail>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.ErrorDetail";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "domain", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorDetail {
    return new ErrorDetail().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorDetail {
    return new ErrorDetail().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorDetail {
    return new ErrorDetail().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorDetail | PlainMessage<ErrorDetail> | undefined, b: ErrorDetail | PlainMessage<ErrorDetail> | undefined): boolean {
    return proto3.util.equals(ErrorDetail, a, b);
  }
}

/**
 * @generated from message grpc.testing.ErrorStatus
 */
export class ErrorStatus extends Message<ErrorStatus> {
  /**
   * @generated from field: int32 code = 1;
   */
  code = 0;

  /**
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * @generated from field: repeated google.protobuf.Any details = 3;
   */
  details: Any[] = [];

  constructor(data?: PartialMessage<ErrorStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "grpc.testing.ErrorStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "details", kind: "message", T: Any, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorStatus {
    return new ErrorStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorStatus {
    return new ErrorStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorStatus {
    return new ErrorStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorStatus | PlainMessage<ErrorStatus> | undefined, b: ErrorStatus | PlainMessage<ErrorStatus> | undefined): boolean {
    return proto3.util.equals(ErrorStatus, a, b);
  }
}

