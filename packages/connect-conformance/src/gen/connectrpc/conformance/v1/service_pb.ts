// Copyright 2021-2025 The Connect Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.2.5 with parameter "target=ts,import_extension=.js"
// @generated from file connectrpc/conformance/v1/service.proto (package connectrpc.conformance.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { Code, Compression } from "./config_pb.js";
import { file_connectrpc_conformance_v1_config } from "./config_pb.js";
import type { Any } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_any } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file connectrpc/conformance/v1/service.proto.
 */
export const file_connectrpc_conformance_v1_service: GenFile = /*@__PURE__*/
  fileDesc("Cidjb25uZWN0cnBjL2NvbmZvcm1hbmNlL3YxL3NlcnZpY2UucHJvdG8SGWNvbm5lY3RycGMuY29uZm9ybWFuY2UudjEiyQIKF1VuYXJ5UmVzcG9uc2VEZWZpbml0aW9uEjsKEHJlc3BvbnNlX2hlYWRlcnMYASADKAsyIS5jb25uZWN0cnBjLmNvbmZvcm1hbmNlLnYxLkhlYWRlchIXCg1yZXNwb25zZV9kYXRhGAIgASgMSAASMQoFZXJyb3IYAyABKAsyIC5jb25uZWN0cnBjLmNvbmZvcm1hbmNlLnYxLkVycm9ySAASPAoRcmVzcG9uc2VfdHJhaWxlcnMYBCADKAsyIS5jb25uZWN0cnBjLmNvbmZvcm1hbmNlLnYxLkhlYWRlchIZChFyZXNwb25zZV9kZWxheV9tcxgGIAEoDRJACgxyYXdfcmVzcG9uc2UYBSABKAsyKi5jb25uZWN0cnBjLmNvbmZvcm1hbmNlLnYxLlJhd0hUVFBSZXNwb25zZUIKCghyZXNwb25zZSK6AgoYU3RyZWFtUmVzcG9uc2VEZWZpbml0aW9uEjsKEHJlc3BvbnNlX2hlYWRlcnMYASADKAsyIS5jb25uZWN0cnBjLmNvbmZvcm1hbmNlLnYxLkhlYWRlchIVCg1yZXNwb25zZV9kYXRhGAIgAygMEhkKEXJlc3BvbnNlX2RlbGF5X21zGAMgASgNEi8KBWVycm9yGAQgASgLMiAuY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5FcnJvchI8ChFyZXNwb25zZV90cmFpbGVycxgFIAMoCzIhLmNvbm5lY3RycGMuY29uZm9ybWFuY2UudjEuSGVhZGVyEkAKDHJhd19yZXNwb25zZRgGIAEoCzIqLmNvbm5lY3RycGMuY29uZm9ybWFuY2UudjEuUmF3SFRUUFJlc3BvbnNlInUKDFVuYXJ5UmVxdWVzdBJPChNyZXNwb25zZV9kZWZpbml0aW9uGAEgASgLMjIuY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5VbmFyeVJlc3BvbnNlRGVmaW5pdGlvbhIUCgxyZXF1ZXN0X2RhdGEYAiABKAwiTwoNVW5hcnlSZXNwb25zZRI+CgdwYXlsb2FkGAEgASgLMi0uY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5Db25mb3JtYW5jZVBheWxvYWQifwoWSWRlbXBvdGVudFVuYXJ5UmVxdWVzdBJPChNyZXNwb25zZV9kZWZpbml0aW9uGAEgASgLMjIuY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5VbmFyeVJlc3BvbnNlRGVmaW5pdGlvbhIUCgxyZXF1ZXN0X2RhdGEYAiABKAwiWQoXSWRlbXBvdGVudFVuYXJ5UmVzcG9uc2USPgoHcGF5bG9hZBgBIAEoCzItLmNvbm5lY3RycGMuY29uZm9ybWFuY2UudjEuQ29uZm9ybWFuY2VQYXlsb2FkIn0KE1NlcnZlclN0cmVhbVJlcXVlc3QSUAoTcmVzcG9uc2VfZGVmaW5pdGlvbhgBIAEoCzIzLmNvbm5lY3RycGMuY29uZm9ybWFuY2UudjEuU3RyZWFtUmVzcG9uc2VEZWZpbml0aW9uEhQKDHJlcXVlc3RfZGF0YRgCIAEoDCJWChRTZXJ2ZXJTdHJlYW1SZXNwb25zZRI+CgdwYXlsb2FkGAEgASgLMi0uY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5Db25mb3JtYW5jZVBheWxvYWQifAoTQ2xpZW50U3RyZWFtUmVxdWVzdBJPChNyZXNwb25zZV9kZWZpbml0aW9uGAEgASgLMjIuY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5VbmFyeVJlc3BvbnNlRGVmaW5pdGlvbhIUCgxyZXF1ZXN0X2RhdGEYAiABKAwiVgoUQ2xpZW50U3RyZWFtUmVzcG9uc2USPgoHcGF5bG9hZBgBIAEoCzItLmNvbm5lY3RycGMuY29uZm9ybWFuY2UudjEuQ29uZm9ybWFuY2VQYXlsb2FkIpABChFCaWRpU3RyZWFtUmVxdWVzdBJQChNyZXNwb25zZV9kZWZpbml0aW9uGAEgASgLMjMuY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5TdHJlYW1SZXNwb25zZURlZmluaXRpb24SEwoLZnVsbF9kdXBsZXgYAiABKAgSFAoMcmVxdWVzdF9kYXRhGAMgASgMIlQKEkJpZGlTdHJlYW1SZXNwb25zZRI+CgdwYXlsb2FkGAEgASgLMi0uY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5Db25mb3JtYW5jZVBheWxvYWQiFgoUVW5pbXBsZW1lbnRlZFJlcXVlc3QiFwoVVW5pbXBsZW1lbnRlZFJlc3BvbnNlIrIDChJDb25mb3JtYW5jZVBheWxvYWQSDAoEZGF0YRgBIAEoDBJPCgxyZXF1ZXN0X2luZm8YAiABKAsyOS5jb25uZWN0cnBjLmNvbmZvcm1hbmNlLnYxLkNvbmZvcm1hbmNlUGF5bG9hZC5SZXF1ZXN0SW5mbxrxAQoLUmVxdWVzdEluZm8SOgoPcmVxdWVzdF9oZWFkZXJzGAEgAygLMiEuY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5IZWFkZXISFwoKdGltZW91dF9tcxgCIAEoA0gAiAEBEiYKCHJlcXVlc3RzGAMgAygLMhQuZ29vZ2xlLnByb3RvYnVmLkFueRJWChBjb25uZWN0X2dldF9pbmZvGAQgASgLMjwuY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5Db25mb3JtYW5jZVBheWxvYWQuQ29ubmVjdEdldEluZm9CDQoLX3RpbWVvdXRfbXMaSQoOQ29ubmVjdEdldEluZm8SNwoMcXVlcnlfcGFyYW1zGAEgAygLMiEuY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5IZWFkZXIifwoFRXJyb3ISLQoEY29kZRgBIAEoDjIfLmNvbm5lY3RycGMuY29uZm9ybWFuY2UudjEuQ29kZRIUCgdtZXNzYWdlGAIgASgJSACIAQESJQoHZGV0YWlscxgDIAMoCzIULmdvb2dsZS5wcm90b2J1Zi5BbnlCCgoIX21lc3NhZ2UiJQoGSGVhZGVyEgwKBG5hbWUYASABKAkSDQoFdmFsdWUYAiADKAki7gMKDlJhd0hUVFBSZXF1ZXN0EgwKBHZlcmIYASABKAkSCwoDdXJpGAIgASgJEjIKB2hlYWRlcnMYAyADKAsyIS5jb25uZWN0cnBjLmNvbmZvcm1hbmNlLnYxLkhlYWRlchI7ChByYXdfcXVlcnlfcGFyYW1zGAQgAygLMiEuY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5IZWFkZXISWQoUZW5jb2RlZF9xdWVyeV9wYXJhbXMYBSADKAsyOy5jb25uZWN0cnBjLmNvbmZvcm1hbmNlLnYxLlJhd0hUVFBSZXF1ZXN0LkVuY29kZWRRdWVyeVBhcmFtEjsKBXVuYXJ5GAYgASgLMiouY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5NZXNzYWdlQ29udGVudHNIABI7CgZzdHJlYW0YByABKAsyKS5jb25uZWN0cnBjLmNvbmZvcm1hbmNlLnYxLlN0cmVhbUNvbnRlbnRzSAAacwoRRW5jb2RlZFF1ZXJ5UGFyYW0SDAoEbmFtZRgBIAEoCRI5CgV2YWx1ZRgCIAEoCzIqLmNvbm5lY3RycGMuY29uZm9ybWFuY2UudjEuTWVzc2FnZUNvbnRlbnRzEhUKDWJhc2U2NF9lbmNvZGUYAyABKAhCBgoEYm9keSKoAQoPTWVzc2FnZUNvbnRlbnRzEhAKBmJpbmFyeRgBIAEoDEgAEg4KBHRleHQYAiABKAlIABIuCg5iaW5hcnlfbWVzc2FnZRgDIAEoCzIULmdvb2dsZS5wcm90b2J1Zi5BbnlIABI7Cgtjb21wcmVzc2lvbhgEIAEoDjImLmNvbm5lY3RycGMuY29uZm9ybWFuY2UudjEuQ29tcHJlc3Npb25CBgoEZGF0YSLPAQoOU3RyZWFtQ29udGVudHMSQwoFaXRlbXMYASADKAsyNC5jb25uZWN0cnBjLmNvbmZvcm1hbmNlLnYxLlN0cmVhbUNvbnRlbnRzLlN0cmVhbUl0ZW0aeAoKU3RyZWFtSXRlbRINCgVmbGFncxgBIAEoDRITCgZsZW5ndGgYAiABKA1IAIgBARI7CgdwYXlsb2FkGAMgASgLMiouY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5NZXNzYWdlQ29udGVudHNCCQoHX2xlbmd0aCKRAgoPUmF3SFRUUFJlc3BvbnNlEhMKC3N0YXR1c19jb2RlGAEgASgNEjIKB2hlYWRlcnMYAiADKAsyIS5jb25uZWN0cnBjLmNvbmZvcm1hbmNlLnYxLkhlYWRlchI7CgV1bmFyeRgDIAEoCzIqLmNvbm5lY3RycGMuY29uZm9ybWFuY2UudjEuTWVzc2FnZUNvbnRlbnRzSAASOwoGc3RyZWFtGAQgASgLMikuY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5TdHJlYW1Db250ZW50c0gAEjMKCHRyYWlsZXJzGAUgAygLMiEuY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5IZWFkZXJCBgoEYm9keTK4BQoSQ29uZm9ybWFuY2VTZXJ2aWNlEloKBVVuYXJ5EicuY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5VbmFyeVJlcXVlc3QaKC5jb25uZWN0cnBjLmNvbmZvcm1hbmNlLnYxLlVuYXJ5UmVzcG9uc2UScQoMU2VydmVyU3RyZWFtEi4uY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5TZXJ2ZXJTdHJlYW1SZXF1ZXN0Gi8uY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5TZXJ2ZXJTdHJlYW1SZXNwb25zZTABEnEKDENsaWVudFN0cmVhbRIuLmNvbm5lY3RycGMuY29uZm9ybWFuY2UudjEuQ2xpZW50U3RyZWFtUmVxdWVzdBovLmNvbm5lY3RycGMuY29uZm9ybWFuY2UudjEuQ2xpZW50U3RyZWFtUmVzcG9uc2UoARJtCgpCaWRpU3RyZWFtEiwuY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5CaWRpU3RyZWFtUmVxdWVzdBotLmNvbm5lY3RycGMuY29uZm9ybWFuY2UudjEuQmlkaVN0cmVhbVJlc3BvbnNlKAEwARJyCg1VbmltcGxlbWVudGVkEi8uY29ubmVjdHJwYy5jb25mb3JtYW5jZS52MS5VbmltcGxlbWVudGVkUmVxdWVzdBowLmNvbm5lY3RycGMuY29uZm9ybWFuY2UudjEuVW5pbXBsZW1lbnRlZFJlc3BvbnNlEn0KD0lkZW1wb3RlbnRVbmFyeRIxLmNvbm5lY3RycGMuY29uZm9ybWFuY2UudjEuSWRlbXBvdGVudFVuYXJ5UmVxdWVzdBoyLmNvbm5lY3RycGMuY29uZm9ybWFuY2UudjEuSWRlbXBvdGVudFVuYXJ5UmVzcG9uc2UiA5ACAWIGcHJvdG8z", [file_connectrpc_conformance_v1_config, file_google_protobuf_any]);

/**
 * A definition of a response to be sent from a single-response endpoint.
 * Can be used to define a response for unary or client-streaming calls.
 *
 * @generated from message connectrpc.conformance.v1.UnaryResponseDefinition
 */
export type UnaryResponseDefinition = Message<"connectrpc.conformance.v1.UnaryResponseDefinition"> & {
  /**
   * Response headers to send
   *
   * @generated from field: repeated connectrpc.conformance.v1.Header response_headers = 1;
   */
  responseHeaders: Header[];

  /**
   * @generated from oneof connectrpc.conformance.v1.UnaryResponseDefinition.response
   */
  response: {
    /**
     * Response data to send
     *
     * @generated from field: bytes response_data = 2;
     */
    value: Uint8Array;
    case: "responseData";
  } | {
    /**
     * Error to raise instead of response message
     * Servers should build a RequestInfo and append it to the details of the
     * requested error.
     *
     * @generated from field: connectrpc.conformance.v1.Error error = 3;
     */
    value: Error;
    case: "error";
  } | { case: undefined; value?: undefined };

  /**
   * Response trailers to send - together with the error if present
   *
   * @generated from field: repeated connectrpc.conformance.v1.Header response_trailers = 4;
   */
  responseTrailers: Header[];

  /**
   * Wait this many milliseconds before sending a response message
   *
   * @generated from field: uint32 response_delay_ms = 6;
   */
  responseDelayMs: number;

  /**
   * This field is only used by the reference server. If you are implementing a
   * server under test, you can ignore this field or respond with an error if the
   * server receives a request where it is set.
   *
   * For test definitions, this field should be used instead of the above fields.
   *
   * @generated from field: connectrpc.conformance.v1.RawHTTPResponse raw_response = 5;
   */
  rawResponse?: RawHTTPResponse;
};

/**
 * Describes the message connectrpc.conformance.v1.UnaryResponseDefinition.
 * Use `create(UnaryResponseDefinitionSchema)` to create a new message.
 */
export const UnaryResponseDefinitionSchema: GenMessage<UnaryResponseDefinition> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 0);

/**
 * A definition of responses to be sent from a streaming endpoint.
 * Can be used to define responses for server-streaming or bidi-streaming calls.
 *
 * @generated from message connectrpc.conformance.v1.StreamResponseDefinition
 */
export type StreamResponseDefinition = Message<"connectrpc.conformance.v1.StreamResponseDefinition"> & {
  /**
   * Response headers to send
   *
   * @generated from field: repeated connectrpc.conformance.v1.Header response_headers = 1;
   */
  responseHeaders: Header[];

  /**
   * Response data to send
   *
   * @generated from field: repeated bytes response_data = 2;
   */
  responseData: Uint8Array[];

  /**
   * Wait this many milliseconds before sending each response message
   *
   * @generated from field: uint32 response_delay_ms = 3;
   */
  responseDelayMs: number;

  /**
   * Optional error to raise, but only after sending any response messages.
   * In the event an immediate error is thrown before any responses are sent,
   * (i.e. the equivalent of a trailers-only response), then servers should
   * build a RequestInfo message with available information and append that to
   * the error details.
   *
   * @generated from field: connectrpc.conformance.v1.Error error = 4;
   */
  error?: Error;

  /**
   * Response trailers to send - together with the error if present
   *
   * @generated from field: repeated connectrpc.conformance.v1.Header response_trailers = 5;
   */
  responseTrailers: Header[];

  /**
   * This field is only used by the reference server. If you are implementing a
   * server under test, you can ignore this field or respond with an error if the
   * server receives a request where it is set.
   *
   * For test definitions, this field should be used instead of the above fields.
   *
   * @generated from field: connectrpc.conformance.v1.RawHTTPResponse raw_response = 6;
   */
  rawResponse?: RawHTTPResponse;
};

/**
 * Describes the message connectrpc.conformance.v1.StreamResponseDefinition.
 * Use `create(StreamResponseDefinitionSchema)` to create a new message.
 */
export const StreamResponseDefinitionSchema: GenMessage<StreamResponseDefinition> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 1);

/**
 * @generated from message connectrpc.conformance.v1.UnaryRequest
 */
export type UnaryRequest = Message<"connectrpc.conformance.v1.UnaryRequest"> & {
  /**
   * The response definition which should be returned in the conformance payload
   *
   * @generated from field: connectrpc.conformance.v1.UnaryResponseDefinition response_definition = 1;
   */
  responseDefinition?: UnaryResponseDefinition;

  /**
   * Additional data. Only used to pad the request size to test large request messages.
   *
   * @generated from field: bytes request_data = 2;
   */
  requestData: Uint8Array;
};

/**
 * Describes the message connectrpc.conformance.v1.UnaryRequest.
 * Use `create(UnaryRequestSchema)` to create a new message.
 */
export const UnaryRequestSchema: GenMessage<UnaryRequest> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 2);

/**
 * @generated from message connectrpc.conformance.v1.UnaryResponse
 */
export type UnaryResponse = Message<"connectrpc.conformance.v1.UnaryResponse"> & {
  /**
   * The conformance payload to respond with.
   *
   * @generated from field: connectrpc.conformance.v1.ConformancePayload payload = 1;
   */
  payload?: ConformancePayload;
};

/**
 * Describes the message connectrpc.conformance.v1.UnaryResponse.
 * Use `create(UnaryResponseSchema)` to create a new message.
 */
export const UnaryResponseSchema: GenMessage<UnaryResponse> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 3);

/**
 * @generated from message connectrpc.conformance.v1.IdempotentUnaryRequest
 */
export type IdempotentUnaryRequest = Message<"connectrpc.conformance.v1.IdempotentUnaryRequest"> & {
  /**
   * The response definition which should be returned in the conformance payload
   *
   * @generated from field: connectrpc.conformance.v1.UnaryResponseDefinition response_definition = 1;
   */
  responseDefinition?: UnaryResponseDefinition;

  /**
   * Additional data. Only used to pad the request size to test large request messages.
   *
   * @generated from field: bytes request_data = 2;
   */
  requestData: Uint8Array;
};

/**
 * Describes the message connectrpc.conformance.v1.IdempotentUnaryRequest.
 * Use `create(IdempotentUnaryRequestSchema)` to create a new message.
 */
export const IdempotentUnaryRequestSchema: GenMessage<IdempotentUnaryRequest> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 4);

/**
 * @generated from message connectrpc.conformance.v1.IdempotentUnaryResponse
 */
export type IdempotentUnaryResponse = Message<"connectrpc.conformance.v1.IdempotentUnaryResponse"> & {
  /**
   * The conformance payload to respond with.
   *
   * @generated from field: connectrpc.conformance.v1.ConformancePayload payload = 1;
   */
  payload?: ConformancePayload;
};

/**
 * Describes the message connectrpc.conformance.v1.IdempotentUnaryResponse.
 * Use `create(IdempotentUnaryResponseSchema)` to create a new message.
 */
export const IdempotentUnaryResponseSchema: GenMessage<IdempotentUnaryResponse> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 5);

/**
 * @generated from message connectrpc.conformance.v1.ServerStreamRequest
 */
export type ServerStreamRequest = Message<"connectrpc.conformance.v1.ServerStreamRequest"> & {
  /**
   * The response definition which should be returned in the conformance payload.
   *
   * @generated from field: connectrpc.conformance.v1.StreamResponseDefinition response_definition = 1;
   */
  responseDefinition?: StreamResponseDefinition;

  /**
   * Additional data. Only used to pad the request size to test large request messages.
   *
   * @generated from field: bytes request_data = 2;
   */
  requestData: Uint8Array;
};

/**
 * Describes the message connectrpc.conformance.v1.ServerStreamRequest.
 * Use `create(ServerStreamRequestSchema)` to create a new message.
 */
export const ServerStreamRequestSchema: GenMessage<ServerStreamRequest> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 6);

/**
 * @generated from message connectrpc.conformance.v1.ServerStreamResponse
 */
export type ServerStreamResponse = Message<"connectrpc.conformance.v1.ServerStreamResponse"> & {
  /**
   * The conformance payload to respond with
   *
   * @generated from field: connectrpc.conformance.v1.ConformancePayload payload = 1;
   */
  payload?: ConformancePayload;
};

/**
 * Describes the message connectrpc.conformance.v1.ServerStreamResponse.
 * Use `create(ServerStreamResponseSchema)` to create a new message.
 */
export const ServerStreamResponseSchema: GenMessage<ServerStreamResponse> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 7);

/**
 * @generated from message connectrpc.conformance.v1.ClientStreamRequest
 */
export type ClientStreamRequest = Message<"connectrpc.conformance.v1.ClientStreamRequest"> & {
  /**
   * Tells the server how to reply once all client messages are
   * complete. Required in the first message in the stream, but
   * should be ignored in subsequent messages.
   *
   * @generated from field: connectrpc.conformance.v1.UnaryResponseDefinition response_definition = 1;
   */
  responseDefinition?: UnaryResponseDefinition;

  /**
   * Additional data for subsequent messages in the stream. Also
   * used to pad the request size to test large request messages.
   *
   * @generated from field: bytes request_data = 2;
   */
  requestData: Uint8Array;
};

/**
 * Describes the message connectrpc.conformance.v1.ClientStreamRequest.
 * Use `create(ClientStreamRequestSchema)` to create a new message.
 */
export const ClientStreamRequestSchema: GenMessage<ClientStreamRequest> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 8);

/**
 * @generated from message connectrpc.conformance.v1.ClientStreamResponse
 */
export type ClientStreamResponse = Message<"connectrpc.conformance.v1.ClientStreamResponse"> & {
  /**
   * The conformance payload to respond with
   *
   * @generated from field: connectrpc.conformance.v1.ConformancePayload payload = 1;
   */
  payload?: ConformancePayload;
};

/**
 * Describes the message connectrpc.conformance.v1.ClientStreamResponse.
 * Use `create(ClientStreamResponseSchema)` to create a new message.
 */
export const ClientStreamResponseSchema: GenMessage<ClientStreamResponse> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 9);

/**
 * @generated from message connectrpc.conformance.v1.BidiStreamRequest
 */
export type BidiStreamRequest = Message<"connectrpc.conformance.v1.BidiStreamRequest"> & {
  /**
   * Tells the server how to reply; required in the first message
   * in the stream. Should be ignored in subsequent messages.
   *
   * @generated from field: connectrpc.conformance.v1.StreamResponseDefinition response_definition = 1;
   */
  responseDefinition?: StreamResponseDefinition;

  /**
   * Tells the server whether it should wait for each request
   * before sending a response.
   *
   * If true, it indicates the server should effectively interleave the
   * stream so messages are sent in request->response pairs.
   *
   * If false, then the response stream will be sent once all request messages
   * are finished sending with the only delays between messages
   * being the optional fixed milliseconds defined in the response
   * definition.
   *
   * This field is only relevant in the first message in the stream
   * and should be ignored in subsequent messages.
   *
   * @generated from field: bool full_duplex = 2;
   */
  fullDuplex: boolean;

  /**
   * Additional data for subsequent messages in the stream. Also
   * used to pad the request size to test large request messages.
   *
   * @generated from field: bytes request_data = 3;
   */
  requestData: Uint8Array;
};

/**
 * Describes the message connectrpc.conformance.v1.BidiStreamRequest.
 * Use `create(BidiStreamRequestSchema)` to create a new message.
 */
export const BidiStreamRequestSchema: GenMessage<BidiStreamRequest> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 10);

/**
 * @generated from message connectrpc.conformance.v1.BidiStreamResponse
 */
export type BidiStreamResponse = Message<"connectrpc.conformance.v1.BidiStreamResponse"> & {
  /**
   * The conformance payload to respond with
   *
   * @generated from field: connectrpc.conformance.v1.ConformancePayload payload = 1;
   */
  payload?: ConformancePayload;
};

/**
 * Describes the message connectrpc.conformance.v1.BidiStreamResponse.
 * Use `create(BidiStreamResponseSchema)` to create a new message.
 */
export const BidiStreamResponseSchema: GenMessage<BidiStreamResponse> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 11);

/**
 * @generated from message connectrpc.conformance.v1.UnimplementedRequest
 */
export type UnimplementedRequest = Message<"connectrpc.conformance.v1.UnimplementedRequest"> & {
};

/**
 * Describes the message connectrpc.conformance.v1.UnimplementedRequest.
 * Use `create(UnimplementedRequestSchema)` to create a new message.
 */
export const UnimplementedRequestSchema: GenMessage<UnimplementedRequest> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 12);

/**
 * @generated from message connectrpc.conformance.v1.UnimplementedResponse
 */
export type UnimplementedResponse = Message<"connectrpc.conformance.v1.UnimplementedResponse"> & {
};

/**
 * Describes the message connectrpc.conformance.v1.UnimplementedResponse.
 * Use `create(UnimplementedResponseSchema)` to create a new message.
 */
export const UnimplementedResponseSchema: GenMessage<UnimplementedResponse> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 13);

/**
 * @generated from message connectrpc.conformance.v1.ConformancePayload
 */
export type ConformancePayload = Message<"connectrpc.conformance.v1.ConformancePayload"> & {
  /**
   * Any response data specified in the response definition to the server should be
   * echoed back here.
   *
   * @generated from field: bytes data = 1;
   */
  data: Uint8Array;

  /**
   * Echoes back information about the request stream observed so far.
   *
   * @generated from field: connectrpc.conformance.v1.ConformancePayload.RequestInfo request_info = 2;
   */
  requestInfo?: ConformancePayload_RequestInfo;
};

/**
 * Describes the message connectrpc.conformance.v1.ConformancePayload.
 * Use `create(ConformancePayloadSchema)` to create a new message.
 */
export const ConformancePayloadSchema: GenMessage<ConformancePayload> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 14);

/**
 * @generated from message connectrpc.conformance.v1.ConformancePayload.RequestInfo
 */
export type ConformancePayload_RequestInfo = Message<"connectrpc.conformance.v1.ConformancePayload.RequestInfo"> & {
  /**
   * The server echos back the request headers it observed here.
   *
   * @generated from field: repeated connectrpc.conformance.v1.Header request_headers = 1;
   */
  requestHeaders: Header[];

  /**
   * The timeout observed that was included in the request. Other timeouts use a
   * type of uint32, but we want to be lenient here to allow whatever value the RPC
   * server observes, even if it's outside the range of uint32.
   *
   * @generated from field: optional int64 timeout_ms = 2;
   */
  timeoutMs?: bigint;

  /**
   * The server should echo back all requests received.
   * For unary and server-streaming requests, this should always contain a single request
   * For client-streaming and half-duplex bidi-streaming, this should contain
   * all client requests in the order received and be present in each response.
   * For full-duplex bidirectional-streaming, this should contain all requests in the order
   * they were received since the last sent response.
   *
   * @generated from field: repeated google.protobuf.Any requests = 3;
   */
  requests: Any[];

  /**
   * If present, the request used the Connect protocol and a GET method. This
   * captures other relevant information about the request. If a server implementation
   * is unable to populate this (due to the server framework not exposing all of these
   * details to application code), it may be an empty message. This implies that the
   * server framework, at a minimum, at least expose to application code whether the
   * request used GET vs. POST.
   *
   * @generated from field: connectrpc.conformance.v1.ConformancePayload.ConnectGetInfo connect_get_info = 4;
   */
  connectGetInfo?: ConformancePayload_ConnectGetInfo;
};

/**
 * Describes the message connectrpc.conformance.v1.ConformancePayload.RequestInfo.
 * Use `create(ConformancePayload_RequestInfoSchema)` to create a new message.
 */
export const ConformancePayload_RequestInfoSchema: GenMessage<ConformancePayload_RequestInfo> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 14, 0);

/**
 * @generated from message connectrpc.conformance.v1.ConformancePayload.ConnectGetInfo
 */
export type ConformancePayload_ConnectGetInfo = Message<"connectrpc.conformance.v1.ConformancePayload.ConnectGetInfo"> & {
  /**
   * The query params observed in the request URL.
   *
   * @generated from field: repeated connectrpc.conformance.v1.Header query_params = 1;
   */
  queryParams: Header[];
};

/**
 * Describes the message connectrpc.conformance.v1.ConformancePayload.ConnectGetInfo.
 * Use `create(ConformancePayload_ConnectGetInfoSchema)` to create a new message.
 */
export const ConformancePayload_ConnectGetInfoSchema: GenMessage<ConformancePayload_ConnectGetInfo> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 14, 1);

/**
 * An error definition used for specifying a desired error response
 *
 * @generated from message connectrpc.conformance.v1.Error
 */
export type Error = Message<"connectrpc.conformance.v1.Error"> & {
  /**
   * The error code.
   * For a list of Connect error codes see: https://connectrpc.com/docs/protocol#error-codes
   *
   * @generated from field: connectrpc.conformance.v1.Code code = 1;
   */
  code: Code;

  /**
   * If this value is absent in a test case response definition, the contents of the
   * actual error message will not be checked. This is useful for certain kinds of
   * error conditions where the exact message to be used is not specified, only the
   * code.
   *
   * @generated from field: optional string message = 2;
   */
  message?: string;

  /**
   * Errors in Connect and gRPC protocols can have arbitrary messages
   * attached to them, which are known as error details.
   *
   * @generated from field: repeated google.protobuf.Any details = 3;
   */
  details: Any[];
};

/**
 * Describes the message connectrpc.conformance.v1.Error.
 * Use `create(ErrorSchema)` to create a new message.
 */
export const ErrorSchema: GenMessage<Error> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 15);

/**
 * A tuple of name and values (ASCII) for a header or trailer entry.
 *
 * @generated from message connectrpc.conformance.v1.Header
 */
export type Header = Message<"connectrpc.conformance.v1.Header"> & {
  /**
   * Header/trailer name (key).
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Header/trailer value. This is repeated to explicitly support headers and
   * trailers where a key is repeated. In such a case, these values must be in
   * the same order as which values appeared in the header or trailer block.
   *
   * @generated from field: repeated string value = 2;
   */
  value: string[];
};

/**
 * Describes the message connectrpc.conformance.v1.Header.
 * Use `create(HeaderSchema)` to create a new message.
 */
export const HeaderSchema: GenMessage<Header> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 16);

/**
 * RawHTTPRequest models a raw HTTP request. This can be used to craft
 * custom requests with odd properties (including certain kinds of
 * malformed requests) to test edge cases in servers.
 *
 * @generated from message connectrpc.conformance.v1.RawHTTPRequest
 */
export type RawHTTPRequest = Message<"connectrpc.conformance.v1.RawHTTPRequest"> & {
  /**
   * The HTTP verb (i.e. GET , POST).
   *
   * @generated from field: string verb = 1;
   */
  verb: string;

  /**
   * The URI to send the request to.
   *
   * @generated from field: string uri = 2;
   */
  uri: string;

  /**
   * Any headers to set on the request.
   *
   * @generated from field: repeated connectrpc.conformance.v1.Header headers = 3;
   */
  headers: Header[];

  /**
   * These query params will be encoded and added to the uri before
   * the request is sent.
   *
   * @generated from field: repeated connectrpc.conformance.v1.Header raw_query_params = 4;
   */
  rawQueryParams: Header[];

  /**
   * This provides an easier way to define a complex binary query param
   * than having to write literal base64-encoded bytes in raw_query_params.
   *
   * @generated from field: repeated connectrpc.conformance.v1.RawHTTPRequest.EncodedQueryParam encoded_query_params = 5;
   */
  encodedQueryParams: RawHTTPRequest_EncodedQueryParam[];

  /**
   * @generated from oneof connectrpc.conformance.v1.RawHTTPRequest.body
   */
  body: {
    /**
     * The body is a single message.
     *
     * @generated from field: connectrpc.conformance.v1.MessageContents unary = 6;
     */
    value: MessageContents;
    case: "unary";
  } | {
    /**
     * The body is a stream, encoded using a five-byte
     * prefix before each item in the stream.
     *
     * @generated from field: connectrpc.conformance.v1.StreamContents stream = 7;
     */
    value: StreamContents;
    case: "stream";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message connectrpc.conformance.v1.RawHTTPRequest.
 * Use `create(RawHTTPRequestSchema)` to create a new message.
 */
export const RawHTTPRequestSchema: GenMessage<RawHTTPRequest> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 17);

/**
 * @generated from message connectrpc.conformance.v1.RawHTTPRequest.EncodedQueryParam
 */
export type RawHTTPRequest_EncodedQueryParam = Message<"connectrpc.conformance.v1.RawHTTPRequest.EncodedQueryParam"> & {
  /**
   * Query param name.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Query param value.
   *
   * @generated from field: connectrpc.conformance.v1.MessageContents value = 2;
   */
  value?: MessageContents;

  /**
   * If true, the message contents will be base64-encoded and the
   * resulting string used as the query parameter value.
   *
   * @generated from field: bool base64_encode = 3;
   */
  base64Encode: boolean;
};

/**
 * Describes the message connectrpc.conformance.v1.RawHTTPRequest.EncodedQueryParam.
 * Use `create(RawHTTPRequest_EncodedQueryParamSchema)` to create a new message.
 */
export const RawHTTPRequest_EncodedQueryParamSchema: GenMessage<RawHTTPRequest_EncodedQueryParam> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 17, 0);

/**
 * MessageContents represents a message in a request body.
 *
 * @generated from message connectrpc.conformance.v1.MessageContents
 */
export type MessageContents = Message<"connectrpc.conformance.v1.MessageContents"> & {
  /**
   * The message data can be defined in one of three ways.
   *
   * @generated from oneof connectrpc.conformance.v1.MessageContents.data
   */
  data: {
    /**
     * Arbitrary bytes.
     *
     * @generated from field: bytes binary = 1;
     */
    value: Uint8Array;
    case: "binary";
  } | {
    /**
     * Arbitrary text.
     *
     * @generated from field: string text = 2;
     */
    value: string;
    case: "text";
  } | {
    /**
     * An actual message. The message inside the Any will be
     * serialized to the protobuf binary formats, and the
     * resulting bytes will be the contents.
     *
     * @generated from field: google.protobuf.Any binary_message = 3;
     */
    value: Any;
    case: "binaryMessage";
  } | { case: undefined; value?: undefined };

  /**
   * If specified and not identity, the above data will be
   * compressed using the given algorithm.
   *
   * @generated from field: connectrpc.conformance.v1.Compression compression = 4;
   */
  compression: Compression;
};

/**
 * Describes the message connectrpc.conformance.v1.MessageContents.
 * Use `create(MessageContentsSchema)` to create a new message.
 */
export const MessageContentsSchema: GenMessage<MessageContents> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 18);

/**
 * StreamContents represents a sequence of messages in a request body.
 *
 * @generated from message connectrpc.conformance.v1.StreamContents
 */
export type StreamContents = Message<"connectrpc.conformance.v1.StreamContents"> & {
  /**
   * The messages in the stream.
   *
   * @generated from field: repeated connectrpc.conformance.v1.StreamContents.StreamItem items = 1;
   */
  items: StreamContents_StreamItem[];
};

/**
 * Describes the message connectrpc.conformance.v1.StreamContents.
 * Use `create(StreamContentsSchema)` to create a new message.
 */
export const StreamContentsSchema: GenMessage<StreamContents> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 19);

/**
 * @generated from message connectrpc.conformance.v1.StreamContents.StreamItem
 */
export type StreamContents_StreamItem = Message<"connectrpc.conformance.v1.StreamContents.StreamItem"> & {
  /**
   * must be in the range 0 to 255.
   *
   * @generated from field: uint32 flags = 1;
   */
  flags: number;

  /**
   * if absent use actual length of payload
   *
   * @generated from field: optional uint32 length = 2;
   */
  length?: number;

  /**
   * @generated from field: connectrpc.conformance.v1.MessageContents payload = 3;
   */
  payload?: MessageContents;
};

/**
 * Describes the message connectrpc.conformance.v1.StreamContents.StreamItem.
 * Use `create(StreamContents_StreamItemSchema)` to create a new message.
 */
export const StreamContents_StreamItemSchema: GenMessage<StreamContents_StreamItem> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 19, 0);

/**
 * RawHTTPResponse models a raw HTTP response. This can be used to craft
 * custom responses with odd properties (including certain kinds of
 * malformed responses) to test edge cases in clients.
 *
 * @generated from message connectrpc.conformance.v1.RawHTTPResponse
 */
export type RawHTTPResponse = Message<"connectrpc.conformance.v1.RawHTTPResponse"> & {
  /**
   * If status code is not specified, it will default to a 200 response code.
   *
   * @generated from field: uint32 status_code = 1;
   */
  statusCode: number;

  /**
   * Headers to be set on the response.
   *
   * @generated from field: repeated connectrpc.conformance.v1.Header headers = 2;
   */
  headers: Header[];

  /**
   * @generated from oneof connectrpc.conformance.v1.RawHTTPResponse.body
   */
  body: {
    /**
     * The body is a single message.
     *
     * @generated from field: connectrpc.conformance.v1.MessageContents unary = 3;
     */
    value: MessageContents;
    case: "unary";
  } | {
    /**
     * The body is a stream, encoded using a five-byte
     * prefix before each item in the stream.
     *
     * @generated from field: connectrpc.conformance.v1.StreamContents stream = 4;
     */
    value: StreamContents;
    case: "stream";
  } | { case: undefined; value?: undefined };

  /**
   * Trailers to be set on the response.
   *
   * @generated from field: repeated connectrpc.conformance.v1.Header trailers = 5;
   */
  trailers: Header[];
};

/**
 * Describes the message connectrpc.conformance.v1.RawHTTPResponse.
 * Use `create(RawHTTPResponseSchema)` to create a new message.
 */
export const RawHTTPResponseSchema: GenMessage<RawHTTPResponse> = /*@__PURE__*/
  messageDesc(file_connectrpc_conformance_v1_service, 20);

/**
 * The service implemented by conformance test servers. This is implemented by
 * the reference servers, used to test clients, and is expected to be implemented
 * by test servers, since this is the service used by reference clients.
 *
 * Test servers must implement the service as described.
 *
 * @generated from service connectrpc.conformance.v1.ConformanceService
 */
export const ConformanceService: GenService<{
  /**
   * A unary operation. The request indicates the response headers and trailers
   * and also indicates either a response message or an error to send back.
   *
   * Response message data is specified as bytes. The service should echo back
   * request properties in the ConformancePayload and then include the message
   * data in the data field.
   *
   * If the response_delay_ms duration is specified, the server should wait the
   * given duration after reading the request before sending the corresponding
   * response.
   *
   * Servers should allow the response definition to be unset in the request and
   * if it is, set no response headers or trailers and return no response data.
   * The returned payload should only contain the request info.
   *
   * @generated from rpc connectrpc.conformance.v1.ConformanceService.Unary
   */
  unary: {
    methodKind: "unary";
    input: typeof UnaryRequestSchema;
    output: typeof UnaryResponseSchema;
  },
  /**
   * A server-streaming operation. The request indicates the response headers,
   * response messages, trailers, and an optional error to send back. The
   * response data should be sent in the order indicated, and the server should
   * wait between sending response messages as indicated.
   *
   * Response message data is specified as bytes. The service should echo back
   * request properties in the first ConformancePayload, and then include the
   * message data in the data field. Subsequent messages after the first one
   * should contain only the data field.
   *
   * Servers should immediately send response headers on the stream before sleeping
   * for any specified response delay and/or sending the first message so that
   * clients can be unblocked reading response headers.
   *
   * If a response definition is not specified OR is specified, but response data
   * is empty, the server should skip sending anything on the stream. When there
   * are no responses to send, servers should throw an error if one is provided
   * and return without error if one is not. Stream headers and trailers should
   * still be set on the stream if provided regardless of whether a response is
   * sent or an error is thrown.
   *
   * @generated from rpc connectrpc.conformance.v1.ConformanceService.ServerStream
   */
  serverStream: {
    methodKind: "server_streaming";
    input: typeof ServerStreamRequestSchema;
    output: typeof ServerStreamResponseSchema;
  },
  /**
   * A client-streaming operation. The first request indicates the response
   * headers and trailers and also indicates either a response message or an
   * error to send back.
   *
   * Response message data is specified as bytes. The service should echo back
   * request properties, including all request messages in the order they were
   * received, in the ConformancePayload and then include the message data in
   * the data field.
   *
   * If the input stream is empty, the server's response will include no data,
   * only the request properties (headers, timeout).
   *
   * Servers should only read the response definition from the first message in
   * the stream and should ignore any definition set in subsequent messages.
   *
   * Servers should allow the response definition to be unset in the request and
   * if it is, set no response headers or trailers and return no response data.
   * The returned payload should only contain the request info.
   *
   * @generated from rpc connectrpc.conformance.v1.ConformanceService.ClientStream
   */
  clientStream: {
    methodKind: "client_streaming";
    input: typeof ClientStreamRequestSchema;
    output: typeof ClientStreamResponseSchema;
  },
  /**
   * A bidirectional-streaming operation. The first request indicates the response
   * headers, response messages, trailers, and an optional error to send back.
   * The response data should be sent in the order indicated, and the server
   * should wait between sending response messages as indicated.
   *
   * Response message data is specified as bytes and should be included in the
   * data field of the ConformancePayload in each response.
   *
   * Servers should send responses indicated according to the rules of half duplex
   * vs. full duplex streams. Once all responses are sent, the server should either
   * return an error if specified or close the stream without error.
   *
   * Servers should immediately send response headers on the stream before sleeping
   * for any specified response delay and/or sending the first message so that
   * clients can be unblocked reading response headers.
   *
   * If a response definition is not specified OR is specified, but response data
   * is empty, the server should skip sending anything on the stream. Stream
   * headers and trailers should always be set on the stream if provided
   * regardless of whether a response is sent or an error is thrown.
   *
   * If the full_duplex field is true:
   * - the handler should read one request and then send back one response, and
   *   then alternate, reading another request and then sending back another response, etc.
   *
   * - if the server receives a request and has no responses to send, it
   *   should throw the error specified in the request.
   *
   * - the service should echo back all request properties in the first response
   *   including the last received request. Subsequent responses should only
   *   echo back the last received request.
   *
   * - if the response_delay_ms duration is specified, the server should wait the given
   *   duration after reading the request before sending the corresponding
   *   response.
   *
   * If the full_duplex field is false:
   * - the handler should read all requests until the client is done sending.
   *   Once all requests are read, the server should then send back any responses
   *   specified in the response definition.
   *
   * - the server should echo back all request properties, including all request
   *   messages in the order they were received, in the first response. Subsequent
   *   responses should only include the message data in the data field.
   *
   * - if the response_delay_ms duration is specified, the server should wait that
   *   long in between sending each response message.
   *
   *
   * @generated from rpc connectrpc.conformance.v1.ConformanceService.BidiStream
   */
  bidiStream: {
    methodKind: "bidi_streaming";
    input: typeof BidiStreamRequestSchema;
    output: typeof BidiStreamResponseSchema;
  },
  /**
   * A unary endpoint that the server should not implement and should instead
   * return an unimplemented error when invoked.
   *
   * @generated from rpc connectrpc.conformance.v1.ConformanceService.Unimplemented
   */
  unimplemented: {
    methodKind: "unary";
    input: typeof UnimplementedRequestSchema;
    output: typeof UnimplementedResponseSchema;
  },
  /**
   * A unary endpoint denoted as having no side effects (i.e. idempotent).
   * Implementations should use an HTTP GET when invoking this endpoint and
   * leverage query parameters to send data.
   *
   * @generated from rpc connectrpc.conformance.v1.ConformanceService.IdempotentUnary
   */
  idempotentUnary: {
    methodKind: "unary";
    input: typeof IdempotentUnaryRequestSchema;
    output: typeof IdempotentUnaryResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_connectrpc_conformance_v1_service, 0);

