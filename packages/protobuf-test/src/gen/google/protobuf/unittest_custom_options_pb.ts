/* eslint-disable */
// @generated by protoc-gen-es v0.0.1 with parameter "ts_nocheck=false"
// @generated from file google/protobuf/unittest_custom_options.proto (package protobuf_unittest, syntax proto2)
//
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// Author: benjy@google.com (Benjy Weinberger)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// A proto file used to test the "custom options" feature of google.protobuf.

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Any, FileOptions, Message, proto2} from "@bufbuild/protobuf";

/**
 * @generated from enum protobuf_unittest.MethodOpt1
 */
export enum MethodOpt1 {

    /**
     * @generated from enum value: METHODOPT1_VAL1 = 1;
     */
    METHODOPT1_VAL1 = 1,

    /**
     * @generated from enum value: METHODOPT1_VAL2 = 2;
     */
    METHODOPT1_VAL2 = 2,

}

// Retrieve enum metadata with: proto2.getEnumType(MethodOpt1)
proto2.util.setEnumType(MethodOpt1, "protobuf_unittest.MethodOpt1", [
    {no: 1, name: "METHODOPT1_VAL1"},
    {no: 2, name: "METHODOPT1_VAL2"},
]);

/**
 * @generated from enum protobuf_unittest.AggregateEnum
 */
export enum AggregateEnum {

    /**
     * @generated from enum value: VALUE = 1;
     */
    VALUE = 1,

}

// Retrieve enum metadata with: proto2.getEnumType(AggregateEnum)
proto2.util.setEnumType(AggregateEnum, "protobuf_unittest.AggregateEnum", [
    {no: 1, name: "VALUE"},
]);

/**
 * A test message with custom options at all possible locations (and also some
 * regular options, to make sure they interact nicely).
 *
 * @generated from message protobuf_unittest.TestMessageWithCustomOptions
 */
export class TestMessageWithCustomOptions extends Message<TestMessageWithCustomOptions> {

    /**
     * @generated from field: optional string field1 = 1;
     */
    field1?: string;

    /**
     * @generated from oneof protobuf_unittest.TestMessageWithCustomOptions.AnOneof
     */
    AnOneof: {
        /**
         * @generated from field: int32 oneof_field = 2;
         */
        value: number;
        case: "oneofField";
    } | { case: undefined; value?: undefined } = { case: undefined };

    /**
     * @generated from field: map<string, string> map_field = 3;
     */
    mapField: { [key: string]: string } = {};

    constructor(data?: PartialMessage<TestMessageWithCustomOptions>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.TestMessageWithCustomOptions";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
        {no: 1, name: "field1", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true},
        {no: 2, name: "oneof_field", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "AnOneof"},
        {no: 3, name: "map_field", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.0 */}},
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestMessageWithCustomOptions {
        return new TestMessageWithCustomOptions().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestMessageWithCustomOptions {
        return new TestMessageWithCustomOptions().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestMessageWithCustomOptions {
        return new TestMessageWithCustomOptions().fromJsonString(jsonString, options);
    }

    static equals(a: TestMessageWithCustomOptions | PlainMessage<TestMessageWithCustomOptions> | undefined, b: TestMessageWithCustomOptions | PlainMessage<TestMessageWithCustomOptions> | undefined): boolean {
        return proto2.util.equals(TestMessageWithCustomOptions, a, b);
    }

}

/**
 * @generated from enum protobuf_unittest.TestMessageWithCustomOptions.AnEnum
 */
export enum TestMessageWithCustomOptions_AnEnum {

    /**
     * @generated from enum value: ANENUM_VAL1 = 1;
     */
    ANENUM_VAL1 = 1,

    /**
     * @generated from enum value: ANENUM_VAL2 = 2;
     */
    ANENUM_VAL2 = 2,

}

// Retrieve enum metadata with: proto2.getEnumType(TestMessageWithCustomOptions_AnEnum)
proto2.util.setEnumType(TestMessageWithCustomOptions_AnEnum, "protobuf_unittest.TestMessageWithCustomOptions.AnEnum", [
    {no: 1, name: "ANENUM_VAL1"},
    {no: 2, name: "ANENUM_VAL2"},
]);


/**
 * A test RPC service with custom options at all possible locations (and also
 * some regular options, to make sure they interact nicely).
 *
 * @generated from message protobuf_unittest.CustomOptionFooRequest
 */
export class CustomOptionFooRequest extends Message<CustomOptionFooRequest> {

    constructor(data?: PartialMessage<CustomOptionFooRequest>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.CustomOptionFooRequest";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomOptionFooRequest {
        return new CustomOptionFooRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomOptionFooRequest {
        return new CustomOptionFooRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomOptionFooRequest {
        return new CustomOptionFooRequest().fromJsonString(jsonString, options);
    }

    static equals(a: CustomOptionFooRequest | PlainMessage<CustomOptionFooRequest> | undefined, b: CustomOptionFooRequest | PlainMessage<CustomOptionFooRequest> | undefined): boolean {
        return proto2.util.equals(CustomOptionFooRequest, a, b);
    }

}


/**
 * @generated from message protobuf_unittest.CustomOptionFooResponse
 */
export class CustomOptionFooResponse extends Message<CustomOptionFooResponse> {

    constructor(data?: PartialMessage<CustomOptionFooResponse>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.CustomOptionFooResponse";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomOptionFooResponse {
        return new CustomOptionFooResponse().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomOptionFooResponse {
        return new CustomOptionFooResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomOptionFooResponse {
        return new CustomOptionFooResponse().fromJsonString(jsonString, options);
    }

    static equals(a: CustomOptionFooResponse | PlainMessage<CustomOptionFooResponse> | undefined, b: CustomOptionFooResponse | PlainMessage<CustomOptionFooResponse> | undefined): boolean {
        return proto2.util.equals(CustomOptionFooResponse, a, b);
    }

}


/**
 * @generated from message protobuf_unittest.CustomOptionFooClientMessage
 */
export class CustomOptionFooClientMessage extends Message<CustomOptionFooClientMessage> {

    constructor(data?: PartialMessage<CustomOptionFooClientMessage>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.CustomOptionFooClientMessage";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomOptionFooClientMessage {
        return new CustomOptionFooClientMessage().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomOptionFooClientMessage {
        return new CustomOptionFooClientMessage().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomOptionFooClientMessage {
        return new CustomOptionFooClientMessage().fromJsonString(jsonString, options);
    }

    static equals(a: CustomOptionFooClientMessage | PlainMessage<CustomOptionFooClientMessage> | undefined, b: CustomOptionFooClientMessage | PlainMessage<CustomOptionFooClientMessage> | undefined): boolean {
        return proto2.util.equals(CustomOptionFooClientMessage, a, b);
    }

}


/**
 * @generated from message protobuf_unittest.CustomOptionFooServerMessage
 */
export class CustomOptionFooServerMessage extends Message<CustomOptionFooServerMessage> {

    constructor(data?: PartialMessage<CustomOptionFooServerMessage>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.CustomOptionFooServerMessage";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomOptionFooServerMessage {
        return new CustomOptionFooServerMessage().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomOptionFooServerMessage {
        return new CustomOptionFooServerMessage().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomOptionFooServerMessage {
        return new CustomOptionFooServerMessage().fromJsonString(jsonString, options);
    }

    static equals(a: CustomOptionFooServerMessage | PlainMessage<CustomOptionFooServerMessage> | undefined, b: CustomOptionFooServerMessage | PlainMessage<CustomOptionFooServerMessage> | undefined): boolean {
        return proto2.util.equals(CustomOptionFooServerMessage, a, b);
    }

}


/**
 * @generated from message protobuf_unittest.DummyMessageContainingEnum
 */
export class DummyMessageContainingEnum extends Message<DummyMessageContainingEnum> {

    constructor(data?: PartialMessage<DummyMessageContainingEnum>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.DummyMessageContainingEnum";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DummyMessageContainingEnum {
        return new DummyMessageContainingEnum().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DummyMessageContainingEnum {
        return new DummyMessageContainingEnum().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DummyMessageContainingEnum {
        return new DummyMessageContainingEnum().fromJsonString(jsonString, options);
    }

    static equals(a: DummyMessageContainingEnum | PlainMessage<DummyMessageContainingEnum> | undefined, b: DummyMessageContainingEnum | PlainMessage<DummyMessageContainingEnum> | undefined): boolean {
        return proto2.util.equals(DummyMessageContainingEnum, a, b);
    }

}

/**
 * @generated from enum protobuf_unittest.DummyMessageContainingEnum.TestEnumType
 */
export enum DummyMessageContainingEnum_TestEnumType {

    /**
     * @generated from enum value: TEST_OPTION_ENUM_TYPE1 = 22;
     */
    TEST_OPTION_ENUM_TYPE1 = 22,

    /**
     * @generated from enum value: TEST_OPTION_ENUM_TYPE2 = -23;
     */
    TEST_OPTION_ENUM_TYPE2 = -23,

}

// Retrieve enum metadata with: proto2.getEnumType(DummyMessageContainingEnum_TestEnumType)
proto2.util.setEnumType(DummyMessageContainingEnum_TestEnumType, "protobuf_unittest.DummyMessageContainingEnum.TestEnumType", [
    {no: 22, name: "TEST_OPTION_ENUM_TYPE1"},
    {no: -23, name: "TEST_OPTION_ENUM_TYPE2"},
]);


/**
 * @generated from message protobuf_unittest.DummyMessageInvalidAsOptionType
 */
export class DummyMessageInvalidAsOptionType extends Message<DummyMessageInvalidAsOptionType> {

    constructor(data?: PartialMessage<DummyMessageInvalidAsOptionType>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.DummyMessageInvalidAsOptionType";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DummyMessageInvalidAsOptionType {
        return new DummyMessageInvalidAsOptionType().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DummyMessageInvalidAsOptionType {
        return new DummyMessageInvalidAsOptionType().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DummyMessageInvalidAsOptionType {
        return new DummyMessageInvalidAsOptionType().fromJsonString(jsonString, options);
    }

    static equals(a: DummyMessageInvalidAsOptionType | PlainMessage<DummyMessageInvalidAsOptionType> | undefined, b: DummyMessageInvalidAsOptionType | PlainMessage<DummyMessageInvalidAsOptionType> | undefined): boolean {
        return proto2.util.equals(DummyMessageInvalidAsOptionType, a, b);
    }

}


/**
 * @generated from message protobuf_unittest.CustomOptionMinIntegerValues
 */
export class CustomOptionMinIntegerValues extends Message<CustomOptionMinIntegerValues> {

    constructor(data?: PartialMessage<CustomOptionMinIntegerValues>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.CustomOptionMinIntegerValues";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomOptionMinIntegerValues {
        return new CustomOptionMinIntegerValues().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomOptionMinIntegerValues {
        return new CustomOptionMinIntegerValues().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomOptionMinIntegerValues {
        return new CustomOptionMinIntegerValues().fromJsonString(jsonString, options);
    }

    static equals(a: CustomOptionMinIntegerValues | PlainMessage<CustomOptionMinIntegerValues> | undefined, b: CustomOptionMinIntegerValues | PlainMessage<CustomOptionMinIntegerValues> | undefined): boolean {
        return proto2.util.equals(CustomOptionMinIntegerValues, a, b);
    }

}


/**
 * @generated from message protobuf_unittest.CustomOptionMaxIntegerValues
 */
export class CustomOptionMaxIntegerValues extends Message<CustomOptionMaxIntegerValues> {

    constructor(data?: PartialMessage<CustomOptionMaxIntegerValues>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.CustomOptionMaxIntegerValues";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomOptionMaxIntegerValues {
        return new CustomOptionMaxIntegerValues().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomOptionMaxIntegerValues {
        return new CustomOptionMaxIntegerValues().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomOptionMaxIntegerValues {
        return new CustomOptionMaxIntegerValues().fromJsonString(jsonString, options);
    }

    static equals(a: CustomOptionMaxIntegerValues | PlainMessage<CustomOptionMaxIntegerValues> | undefined, b: CustomOptionMaxIntegerValues | PlainMessage<CustomOptionMaxIntegerValues> | undefined): boolean {
        return proto2.util.equals(CustomOptionMaxIntegerValues, a, b);
    }

}


/**
 * @generated from message protobuf_unittest.CustomOptionOtherValues
 */
export class CustomOptionOtherValues extends Message<CustomOptionOtherValues> {

    constructor(data?: PartialMessage<CustomOptionOtherValues>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.CustomOptionOtherValues";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomOptionOtherValues {
        return new CustomOptionOtherValues().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomOptionOtherValues {
        return new CustomOptionOtherValues().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomOptionOtherValues {
        return new CustomOptionOtherValues().fromJsonString(jsonString, options);
    }

    static equals(a: CustomOptionOtherValues | PlainMessage<CustomOptionOtherValues> | undefined, b: CustomOptionOtherValues | PlainMessage<CustomOptionOtherValues> | undefined): boolean {
        return proto2.util.equals(CustomOptionOtherValues, a, b);
    }

}


/**
 * @generated from message protobuf_unittest.SettingRealsFromPositiveInts
 */
export class SettingRealsFromPositiveInts extends Message<SettingRealsFromPositiveInts> {

    constructor(data?: PartialMessage<SettingRealsFromPositiveInts>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.SettingRealsFromPositiveInts";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SettingRealsFromPositiveInts {
        return new SettingRealsFromPositiveInts().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SettingRealsFromPositiveInts {
        return new SettingRealsFromPositiveInts().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SettingRealsFromPositiveInts {
        return new SettingRealsFromPositiveInts().fromJsonString(jsonString, options);
    }

    static equals(a: SettingRealsFromPositiveInts | PlainMessage<SettingRealsFromPositiveInts> | undefined, b: SettingRealsFromPositiveInts | PlainMessage<SettingRealsFromPositiveInts> | undefined): boolean {
        return proto2.util.equals(SettingRealsFromPositiveInts, a, b);
    }

}


/**
 * @generated from message protobuf_unittest.SettingRealsFromNegativeInts
 */
export class SettingRealsFromNegativeInts extends Message<SettingRealsFromNegativeInts> {

    constructor(data?: PartialMessage<SettingRealsFromNegativeInts>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.SettingRealsFromNegativeInts";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SettingRealsFromNegativeInts {
        return new SettingRealsFromNegativeInts().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SettingRealsFromNegativeInts {
        return new SettingRealsFromNegativeInts().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SettingRealsFromNegativeInts {
        return new SettingRealsFromNegativeInts().fromJsonString(jsonString, options);
    }

    static equals(a: SettingRealsFromNegativeInts | PlainMessage<SettingRealsFromNegativeInts> | undefined, b: SettingRealsFromNegativeInts | PlainMessage<SettingRealsFromNegativeInts> | undefined): boolean {
        return proto2.util.equals(SettingRealsFromNegativeInts, a, b);
    }

}


/**
 * @generated from message protobuf_unittest.ComplexOptionType1
 */
export class ComplexOptionType1 extends Message<ComplexOptionType1> {

    /**
     * @generated from field: optional int32 foo = 1;
     */
    foo?: number;

    /**
     * @generated from field: optional int32 foo2 = 2;
     */
    foo2?: number;

    /**
     * @generated from field: optional int32 foo3 = 3;
     */
    foo3?: number;

    /**
     * @generated from field: repeated int32 foo4 = 4;
     */
    foo4: number[] = [];

    constructor(data?: PartialMessage<ComplexOptionType1>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.ComplexOptionType1";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
        {no: 1, name: "foo", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true},
        {no: 2, name: "foo2", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true},
        {no: 3, name: "foo3", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true},
        {no: 4, name: "foo4", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true},
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComplexOptionType1 {
        return new ComplexOptionType1().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComplexOptionType1 {
        return new ComplexOptionType1().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComplexOptionType1 {
        return new ComplexOptionType1().fromJsonString(jsonString, options);
    }

    static equals(a: ComplexOptionType1 | PlainMessage<ComplexOptionType1> | undefined, b: ComplexOptionType1 | PlainMessage<ComplexOptionType1> | undefined): boolean {
        return proto2.util.equals(ComplexOptionType1, a, b);
    }

}


/**
 * @generated from message protobuf_unittest.ComplexOptionType2
 */
export class ComplexOptionType2 extends Message<ComplexOptionType2> {

    /**
     * @generated from field: optional protobuf_unittest.ComplexOptionType1 bar = 1;
     */
    bar?: ComplexOptionType1;

    /**
     * @generated from field: optional int32 baz = 2;
     */
    baz?: number;

    /**
     * @generated from field: optional protobuf_unittest.ComplexOptionType2.ComplexOptionType4 fred = 3;
     */
    fred?: ComplexOptionType2_ComplexOptionType4;

    /**
     * @generated from field: repeated protobuf_unittest.ComplexOptionType2.ComplexOptionType4 barney = 4;
     */
    barney: ComplexOptionType2_ComplexOptionType4[] = [];

    constructor(data?: PartialMessage<ComplexOptionType2>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.ComplexOptionType2";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
        {no: 1, name: "bar", kind: "message", T: ComplexOptionType1, opt: true},
        {no: 2, name: "baz", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true},
        {no: 3, name: "fred", kind: "message", T: ComplexOptionType2_ComplexOptionType4, opt: true},
        {no: 4, name: "barney", kind: "message", T: ComplexOptionType2_ComplexOptionType4, repeated: true},
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComplexOptionType2 {
        return new ComplexOptionType2().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComplexOptionType2 {
        return new ComplexOptionType2().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComplexOptionType2 {
        return new ComplexOptionType2().fromJsonString(jsonString, options);
    }

    static equals(a: ComplexOptionType2 | PlainMessage<ComplexOptionType2> | undefined, b: ComplexOptionType2 | PlainMessage<ComplexOptionType2> | undefined): boolean {
        return proto2.util.equals(ComplexOptionType2, a, b);
    }

}

/**
 * @generated from message protobuf_unittest.ComplexOptionType2.ComplexOptionType4
 */
export class ComplexOptionType2_ComplexOptionType4 extends Message<ComplexOptionType2_ComplexOptionType4> {

    /**
     * @generated from field: optional int32 waldo = 1;
     */
    waldo?: number;

    constructor(data?: PartialMessage<ComplexOptionType2_ComplexOptionType4>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.ComplexOptionType2.ComplexOptionType4";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
        {no: 1, name: "waldo", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true},
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComplexOptionType2_ComplexOptionType4 {
        return new ComplexOptionType2_ComplexOptionType4().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComplexOptionType2_ComplexOptionType4 {
        return new ComplexOptionType2_ComplexOptionType4().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComplexOptionType2_ComplexOptionType4 {
        return new ComplexOptionType2_ComplexOptionType4().fromJsonString(jsonString, options);
    }

    static equals(a: ComplexOptionType2_ComplexOptionType4 | PlainMessage<ComplexOptionType2_ComplexOptionType4> | undefined, b: ComplexOptionType2_ComplexOptionType4 | PlainMessage<ComplexOptionType2_ComplexOptionType4> | undefined): boolean {
        return proto2.util.equals(ComplexOptionType2_ComplexOptionType4, a, b);
    }

}



/**
 * @generated from message protobuf_unittest.ComplexOptionType3
 */
export class ComplexOptionType3 extends Message<ComplexOptionType3> {

    /**
     * @generated from field: optional int32 qux = 1;
     */
    qux?: number;

    /**
     * @generated from field: optional protobuf_unittest.ComplexOptionType3.ComplexOptionType5 complexoptiontype5 = 2;
     */
    complexoptiontype5?: ComplexOptionType3_ComplexOptionType5;

    constructor(data?: PartialMessage<ComplexOptionType3>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.ComplexOptionType3";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
        {no: 1, name: "qux", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true},
        {no: 2, name: "complexoptiontype5", kind: "message", T: ComplexOptionType3_ComplexOptionType5, opt: true},
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComplexOptionType3 {
        return new ComplexOptionType3().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComplexOptionType3 {
        return new ComplexOptionType3().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComplexOptionType3 {
        return new ComplexOptionType3().fromJsonString(jsonString, options);
    }

    static equals(a: ComplexOptionType3 | PlainMessage<ComplexOptionType3> | undefined, b: ComplexOptionType3 | PlainMessage<ComplexOptionType3> | undefined): boolean {
        return proto2.util.equals(ComplexOptionType3, a, b);
    }

}

/**
 * @generated from message protobuf_unittest.ComplexOptionType3.ComplexOptionType5
 */
export class ComplexOptionType3_ComplexOptionType5 extends Message<ComplexOptionType3_ComplexOptionType5> {

    /**
     * @generated from field: optional int32 plugh = 3;
     */
    plugh?: number;

    constructor(data?: PartialMessage<ComplexOptionType3_ComplexOptionType5>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.ComplexOptionType3.ComplexOptionType5";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
        {no: 3, name: "plugh", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true},
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComplexOptionType3_ComplexOptionType5 {
        return new ComplexOptionType3_ComplexOptionType5().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComplexOptionType3_ComplexOptionType5 {
        return new ComplexOptionType3_ComplexOptionType5().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComplexOptionType3_ComplexOptionType5 {
        return new ComplexOptionType3_ComplexOptionType5().fromJsonString(jsonString, options);
    }

    static equals(a: ComplexOptionType3_ComplexOptionType5 | PlainMessage<ComplexOptionType3_ComplexOptionType5> | undefined, b: ComplexOptionType3_ComplexOptionType5 | PlainMessage<ComplexOptionType3_ComplexOptionType5> | undefined): boolean {
        return proto2.util.equals(ComplexOptionType3_ComplexOptionType5, a, b);
    }

}



/**
 * @generated from message protobuf_unittest.ComplexOpt6
 */
export class ComplexOpt6 extends Message<ComplexOpt6> {

    /**
     * @generated from field: optional int32 xyzzy = 7593951;
     */
    xyzzy?: number;

    constructor(data?: PartialMessage<ComplexOpt6>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.ComplexOpt6";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
        {no: 7593951, name: "xyzzy", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true},
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComplexOpt6 {
        return new ComplexOpt6().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComplexOpt6 {
        return new ComplexOpt6().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComplexOpt6 {
        return new ComplexOpt6().fromJsonString(jsonString, options);
    }

    static equals(a: ComplexOpt6 | PlainMessage<ComplexOpt6> | undefined, b: ComplexOpt6 | PlainMessage<ComplexOpt6> | undefined): boolean {
        return proto2.util.equals(ComplexOpt6, a, b);
    }

}


/**
 * Note that we try various different ways of naming the same extension.
 *
 * @generated from message protobuf_unittest.VariousComplexOptions
 */
export class VariousComplexOptions extends Message<VariousComplexOptions> {

    constructor(data?: PartialMessage<VariousComplexOptions>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.VariousComplexOptions";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VariousComplexOptions {
        return new VariousComplexOptions().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VariousComplexOptions {
        return new VariousComplexOptions().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VariousComplexOptions {
        return new VariousComplexOptions().fromJsonString(jsonString, options);
    }

    static equals(a: VariousComplexOptions | PlainMessage<VariousComplexOptions> | undefined, b: VariousComplexOptions | PlainMessage<VariousComplexOptions> | undefined): boolean {
        return proto2.util.equals(VariousComplexOptions, a, b);
    }

}


/**
 * @generated from message protobuf_unittest.AggregateMessageSet
 */
export class AggregateMessageSet extends Message<AggregateMessageSet> {

    constructor(data?: PartialMessage<AggregateMessageSet>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.AggregateMessageSet";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregateMessageSet {
        return new AggregateMessageSet().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregateMessageSet {
        return new AggregateMessageSet().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregateMessageSet {
        return new AggregateMessageSet().fromJsonString(jsonString, options);
    }

    static equals(a: AggregateMessageSet | PlainMessage<AggregateMessageSet> | undefined, b: AggregateMessageSet | PlainMessage<AggregateMessageSet> | undefined): boolean {
        return proto2.util.equals(AggregateMessageSet, a, b);
    }

}


/**
 * @generated from message protobuf_unittest.AggregateMessageSetElement
 */
export class AggregateMessageSetElement extends Message<AggregateMessageSetElement> {

    /**
     * @generated from field: optional string s = 1;
     */
    s?: string;

    constructor(data?: PartialMessage<AggregateMessageSetElement>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.AggregateMessageSetElement";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
        {no: 1, name: "s", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true},
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregateMessageSetElement {
        return new AggregateMessageSetElement().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregateMessageSetElement {
        return new AggregateMessageSetElement().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregateMessageSetElement {
        return new AggregateMessageSetElement().fromJsonString(jsonString, options);
    }

    static equals(a: AggregateMessageSetElement | PlainMessage<AggregateMessageSetElement> | undefined, b: AggregateMessageSetElement | PlainMessage<AggregateMessageSetElement> | undefined): boolean {
        return proto2.util.equals(AggregateMessageSetElement, a, b);
    }

}


/**
 * A helper type used to test aggregate option parsing
 *
 * @generated from message protobuf_unittest.Aggregate
 */
export class Aggregate extends Message<Aggregate> {

    /**
     * @generated from field: optional int32 i = 1;
     */
    i?: number;

    /**
     * @generated from field: optional string s = 2;
     */
    s?: string;

    /**
     * A nested object
     *
     * @generated from field: optional protobuf_unittest.Aggregate sub = 3;
     */
    sub?: Aggregate;

    /**
     * To test the parsing of extensions inside aggregate values
     *
     * @generated from field: optional google.protobuf.FileOptions file = 4;
     */
    file?: FileOptions;

    /**
     * An embedded message set
     *
     * @generated from field: optional protobuf_unittest.AggregateMessageSet mset = 5;
     */
    mset?: AggregateMessageSet;

    /**
     * An any
     *
     * @generated from field: optional google.protobuf.Any any = 6;
     */
    any?: Any;

    constructor(data?: PartialMessage<Aggregate>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.Aggregate";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
        {no: 1, name: "i", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true},
        {no: 2, name: "s", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true},
        {no: 3, name: "sub", kind: "message", T: Aggregate, opt: true},
        {no: 4, name: "file", kind: "message", T: FileOptions, opt: true},
        {no: 5, name: "mset", kind: "message", T: AggregateMessageSet, opt: true},
        {no: 6, name: "any", kind: "message", T: Any, opt: true},
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Aggregate {
        return new Aggregate().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Aggregate {
        return new Aggregate().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Aggregate {
        return new Aggregate().fromJsonString(jsonString, options);
    }

    static equals(a: Aggregate | PlainMessage<Aggregate> | undefined, b: Aggregate | PlainMessage<Aggregate> | undefined): boolean {
        return proto2.util.equals(Aggregate, a, b);
    }

}


/**
 * @generated from message protobuf_unittest.AggregateMessage
 */
export class AggregateMessage extends Message<AggregateMessage> {

    /**
     * @generated from field: optional int32 fieldname = 1;
     */
    fieldname?: number;

    constructor(data?: PartialMessage<AggregateMessage>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.AggregateMessage";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
        {no: 1, name: "fieldname", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true},
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregateMessage {
        return new AggregateMessage().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregateMessage {
        return new AggregateMessage().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregateMessage {
        return new AggregateMessage().fromJsonString(jsonString, options);
    }

    static equals(a: AggregateMessage | PlainMessage<AggregateMessage> | undefined, b: AggregateMessage | PlainMessage<AggregateMessage> | undefined): boolean {
        return proto2.util.equals(AggregateMessage, a, b);
    }

}


/**
 * Test custom options for nested type.
 *
 * @generated from message protobuf_unittest.NestedOptionType
 */
export class NestedOptionType extends Message<NestedOptionType> {

    constructor(data?: PartialMessage<NestedOptionType>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.NestedOptionType";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NestedOptionType {
        return new NestedOptionType().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NestedOptionType {
        return new NestedOptionType().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NestedOptionType {
        return new NestedOptionType().fromJsonString(jsonString, options);
    }

    static equals(a: NestedOptionType | PlainMessage<NestedOptionType> | undefined, b: NestedOptionType | PlainMessage<NestedOptionType> | undefined): boolean {
        return proto2.util.equals(NestedOptionType, a, b);
    }

}

/**
 * @generated from enum protobuf_unittest.NestedOptionType.NestedEnum
 */
export enum NestedOptionType_NestedEnum {

    /**
     * @generated from enum value: NESTED_ENUM_VALUE = 1;
     */
    VALUE = 1,

}

// Retrieve enum metadata with: proto2.getEnumType(NestedOptionType_NestedEnum)
proto2.util.setEnumType(NestedOptionType_NestedEnum, "protobuf_unittest.NestedOptionType.NestedEnum", [
    {no: 1, name: "NESTED_ENUM_VALUE"},
]);

/**
 * @generated from message protobuf_unittest.NestedOptionType.NestedMessage
 */
export class NestedOptionType_NestedMessage extends Message<NestedOptionType_NestedMessage> {

    /**
     * @generated from field: optional int32 nested_field = 1;
     */
    nestedField?: number;

    constructor(data?: PartialMessage<NestedOptionType_NestedMessage>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.NestedOptionType.NestedMessage";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
        {no: 1, name: "nested_field", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true},
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NestedOptionType_NestedMessage {
        return new NestedOptionType_NestedMessage().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NestedOptionType_NestedMessage {
        return new NestedOptionType_NestedMessage().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NestedOptionType_NestedMessage {
        return new NestedOptionType_NestedMessage().fromJsonString(jsonString, options);
    }

    static equals(a: NestedOptionType_NestedMessage | PlainMessage<NestedOptionType_NestedMessage> | undefined, b: NestedOptionType_NestedMessage | PlainMessage<NestedOptionType_NestedMessage> | undefined): boolean {
        return proto2.util.equals(NestedOptionType_NestedMessage, a, b);
    }

}



/**
 * Custom message option that has a required enum field.
 * WARNING: this is strongly discouraged!
 *
 * @generated from message protobuf_unittest.OldOptionType
 */
export class OldOptionType extends Message<OldOptionType> {

    /**
     * @generated from field: required protobuf_unittest.OldOptionType.TestEnum value = 1;
     */
    value?: OldOptionType_TestEnum;

    constructor(data?: PartialMessage<OldOptionType>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.OldOptionType";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
        {no: 1, name: "value", kind: "enum", T: proto2.getEnumType(OldOptionType_TestEnum)},
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OldOptionType {
        return new OldOptionType().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OldOptionType {
        return new OldOptionType().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OldOptionType {
        return new OldOptionType().fromJsonString(jsonString, options);
    }

    static equals(a: OldOptionType | PlainMessage<OldOptionType> | undefined, b: OldOptionType | PlainMessage<OldOptionType> | undefined): boolean {
        return proto2.util.equals(OldOptionType, a, b);
    }

}

/**
 * @generated from enum protobuf_unittest.OldOptionType.TestEnum
 */
export enum OldOptionType_TestEnum {

    /**
     * @generated from enum value: OLD_VALUE = 0;
     */
    OLD_VALUE = 0,

}

// Retrieve enum metadata with: proto2.getEnumType(OldOptionType_TestEnum)
proto2.util.setEnumType(OldOptionType_TestEnum, "protobuf_unittest.OldOptionType.TestEnum", [
    {no: 0, name: "OLD_VALUE"},
]);


/**
 * Updated version of the custom option above.
 *
 * @generated from message protobuf_unittest.NewOptionType
 */
export class NewOptionType extends Message<NewOptionType> {

    /**
     * @generated from field: required protobuf_unittest.NewOptionType.TestEnum value = 1;
     */
    value?: NewOptionType_TestEnum;

    constructor(data?: PartialMessage<NewOptionType>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.NewOptionType";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
        {no: 1, name: "value", kind: "enum", T: proto2.getEnumType(NewOptionType_TestEnum)},
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NewOptionType {
        return new NewOptionType().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NewOptionType {
        return new NewOptionType().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NewOptionType {
        return new NewOptionType().fromJsonString(jsonString, options);
    }

    static equals(a: NewOptionType | PlainMessage<NewOptionType> | undefined, b: NewOptionType | PlainMessage<NewOptionType> | undefined): boolean {
        return proto2.util.equals(NewOptionType, a, b);
    }

}

/**
 * @generated from enum protobuf_unittest.NewOptionType.TestEnum
 */
export enum NewOptionType_TestEnum {

    /**
     * @generated from enum value: OLD_VALUE = 0;
     */
    OLD_VALUE = 0,

    /**
     * @generated from enum value: NEW_VALUE = 1;
     */
    NEW_VALUE = 1,

}

// Retrieve enum metadata with: proto2.getEnumType(NewOptionType_TestEnum)
proto2.util.setEnumType(NewOptionType_TestEnum, "protobuf_unittest.NewOptionType.TestEnum", [
    {no: 0, name: "OLD_VALUE"},
    {no: 1, name: "NEW_VALUE"},
]);


/**
 * Test message using the "required_enum_opt" option defined above.
 *
 * @generated from message protobuf_unittest.TestMessageWithRequiredEnumOption
 */
export class TestMessageWithRequiredEnumOption extends Message<TestMessageWithRequiredEnumOption> {

    constructor(data?: PartialMessage<TestMessageWithRequiredEnumOption>) {
        super();
        proto2.util.initPartial(data, this);
    }

    static readonly runtime = proto2;
    static readonly typeName = "protobuf_unittest.TestMessageWithRequiredEnumOption";
    static readonly fields: FieldList = proto2.util.newFieldList(() => [
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestMessageWithRequiredEnumOption {
        return new TestMessageWithRequiredEnumOption().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestMessageWithRequiredEnumOption {
        return new TestMessageWithRequiredEnumOption().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestMessageWithRequiredEnumOption {
        return new TestMessageWithRequiredEnumOption().fromJsonString(jsonString, options);
    }

    static equals(a: TestMessageWithRequiredEnumOption | PlainMessage<TestMessageWithRequiredEnumOption> | undefined, b: TestMessageWithRequiredEnumOption | PlainMessage<TestMessageWithRequiredEnumOption> | undefined): boolean {
        return proto2.util.equals(TestMessageWithRequiredEnumOption, a, b);
    }

}


